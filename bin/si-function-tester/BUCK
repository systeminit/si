load(
    "@prelude-si//:deno.bzl",
    "deno_format",
    "deno_test",
)
load(
    "@prelude-si//:macros.bzl",
    "alias",
    "deno_binary",
    "container_image",
    "export_file",
)

deno_binary(
    name = "si-function-tester-server",
    main = "server.ts",
    srcs = glob([
        "*.ts",
    ]),
    permissions = [
        "allow-all",
    ],
)

deno_binary(
    name = "si-function-tester-client",
    main = "client.ts",
    srcs = glob([
        "*.ts",
    ]),
    permissions = [
        "allow-read",
        "allow-net",
    ],
)

deno_format(
    name = "fix-format",
    srcs = glob(
        ["**/*.ts"],
        exclude = ["examples/**"],
    ),
)

deno_format(
    name = "check-format",
    srcs = glob(
        ["**/*.ts"],
        exclude = ["examples/**"],
    ),
    check = True,
)

# There are no unit tests for this. This tricks the build
# system into building the binary as its unit test suite which will force a lint and basic compile
# correctness check.
alias(
    name = "test-unit",
    actual = ":si-function-tester-server",
)

# Export source files for Docker image
export_file(
    name = "types.ts",
)

export_file(
    name = "mocks.ts",
)

export_file(
    name = "runner.ts",
)

export_file(
    name = "index.ts",
)

export_file(
    name = "server.ts",
)

export_file(
    name = "deno.json",
)

container_image(
    name = "si-function-tester",
    flake_lock = "//:flake.lock",
    srcs = {
        ":types.ts": ".",
        ":mocks.ts": ".",
        ":runner.ts": ".",
        ":index.ts": ".",
        ":server.ts": ".",
        ":deno.json": ".",
    },
)
