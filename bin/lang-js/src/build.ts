// This script builds `sandbox.ts` and its dependencies into a single bundled
// file called `bundle.js`. It is used during Deno execution to avoid
// downloading modules during runtime in Firecracker microVMs.

import * as esbuild from "https://deno.land/x/esbuild@v0.20.0/mod.js";
import { dirname, fromFileUrl, join } from "https://deno.land/std/path/mod.ts";
import { denoPlugins } from "jsr:@luca/esbuild-deno-loader@^0.11.1";

export async function buildSandbox(outputPath?: string) {
  const baseDir = dirname(fromFileUrl(import.meta.url));

  // Create a unique cache directory for this process to avoid esbuild cache conflicts
  const processId = `${Date.now()}-${Math.random().toString(36).substring(7)}`;
  const uniqueCacheDir = Deno.env.get("TMPDIR") || Deno.env.get("TMP") || "/tmp";
  const esbuildCacheDir = join(uniqueCacheDir, `esbuild-cache-${processId}`);
  
  // Set the ESBUILD_CACHE_DIR environment variable to use our unique directory
  const originalEsbuildCache = Deno.env.get("ESBUILD_CACHE_DIR");
  Deno.env.set("ESBUILD_CACHE_DIR", esbuildCacheDir);
  
  try {
    // Ensure the cache directory exists
    await Deno.mkdir(esbuildCacheDir, { recursive: true });

    const result = await esbuild.build({
      plugins: denoPlugins({}),
      entryPoints: [join(baseDir, "sandbox.ts")],
      bundle: true,
      format: "esm",
      platform: "node",
      write: false,
      banner: {
        js:
          `import { createRequire } from 'node:module';const require = createRequire(import.meta.url);// INJECTION_POINT - DO NOT REMOVE THIS LINE`,
      },
      define: {
        "import.meta.main": "false",
        "process.env.NODE_ENV": '"production"',
        global: "globalThis",
      },
      sourcemap: false,
      minify: true,
      minifyWhitespace: true,
      minifyIdentifiers: true,
      minifySyntax: true,
      treeShaking: true,
      charset: "utf8",
      legalComments: "none",
      keepNames: false,
      absWorkingDir: baseDir,
      drop: ["debugger"],
    });

    if (!result.outputFiles?.[0]) {
      throw new Error("❌ No output file generated by esbuild.");
    }

    const bundleContent = result.outputFiles[0].text;
    const targetPath = outputPath ?? join(baseDir, "bundle.js");

    await Deno.writeTextFile(
      targetPath,
      bundleContent,
    );

    console.log(
      `✅ Built sandbox bundle → ${targetPath} (${bundleContent.length} bytes)`,
    );

    return result;
  } finally {
    // Restore the original ESBUILD_CACHE_DIR environment variable
    if (originalEsbuildCache !== undefined) {
      Deno.env.set("ESBUILD_CACHE_DIR", originalEsbuildCache);
    } else {
      Deno.env.delete("ESBUILD_CACHE_DIR");
    }
    
    // Clean up the temporary cache directory
    try {
      await Deno.remove(esbuildCacheDir, { recursive: true });
    } catch (e) {
      // Ignore cleanup errors - directory might not exist or be in use
    }
  }
}

// Function to generate TypeScript file with embedded bundle
async function generateBundleModule(bundleContent: string, outputPath: string) {
  const moduleContent = `// Auto-generated file containing pre-built sandbox bundle
// This file is generated by build.ts and should not be edited manually

export const PRE_BUILT_BUNDLE = ${JSON.stringify(bundleContent)};
`;
  
  await Deno.writeTextFile(outputPath, moduleContent);
  console.log(`✅ Generated bundle module → ${outputPath}`);
}

if (import.meta.main) {
  const output = Deno.args[0];
  
  // Build the sandbox bundle
  const result = await buildSandbox();
  
  if (result.outputFiles?.[0]) {
    const bundleContent = result.outputFiles[0].text;
    
    // Write the TypeScript module with embedded bundle to the specified output
    await generateBundleModule(bundleContent, output);
  } else {
    throw new Error("Failed to build sandbox bundle");
  }
}
