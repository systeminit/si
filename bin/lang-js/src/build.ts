// This script builds `sandbox.ts` and its dependencies into a single bundled
// file called `bundle.js`. It is used during Deno execution to avoid
// downloading modules during runtime in Firecracker microVMs.

import * as esbuild from "https://deno.land/x/esbuild@v0.20.0/mod.js";
import { dirname, fromFileUrl, join } from "https://deno.land/std/path/mod.ts";
import { denoPlugins } from "jsr:@luca/esbuild-deno-loader@^0.11.1";

export async function buildSandbox(outputPath?: string) {
  const baseDir = dirname(fromFileUrl(import.meta.url));

  const result = await esbuild.build({
    plugins: denoPlugins({}),
    entryPoints: [join(baseDir, "sandbox.ts")],
    bundle: true,
    format: "esm",
    platform: "node",
    write: false,
    banner: {
      js:
        `import { createRequire } from 'node:module';const require = createRequire(import.meta.url);// INJECTION_POINT - DO NOT REMOVE THIS LINE`,
    },
    define: {
      "import.meta.main": "false",
      "process.env.NODE_ENV": '"production"',
      global: "globalThis",
    },
    sourcemap: false,
    minify: true,
    minifyWhitespace: true,
    minifyIdentifiers: true,
    minifySyntax: true,
    treeShaking: true,
    charset: "utf8",
    legalComments: "none",
    keepNames: false,
    absWorkingDir: baseDir,
    drop: ["debugger"],
  });

  if (!result.outputFiles?.[0]) {
    throw new Error("❌ No output file generated by esbuild.");
  }

  const bundleContent = result.outputFiles[0].text;
  const targetPath = outputPath ?? join(baseDir, "bundle.js");

  await Deno.writeTextFile(
    targetPath,
    bundleContent,
  );

  console.log(
    `✅ Built sandbox bundle → ${targetPath} (${bundleContent.length} bytes)`,
  );
}

if (import.meta.main) {
  const output = Deno.args[0];
  await buildSandbox(output);
}
