import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { ComponentsApi, ManagementFuncsApi } from "@systeminit/api-client";
import { apiConfig, WORKSPACE_ID } from "../si_client.ts";
import {
  errorResponse,
  generateDescription,
  successResponse,
} from "./commonBehavior.ts";
import { AttributesSchema } from "../data/components.ts";

const name = "component-import";
const title = "Import a component of a given schema and resource id";
const description =
  `<description>Import a component for a given schema name and resourceId into a change set.</description><usage>Use this tool to bring an existing resource into System Initiative. For example, if the user asks to import the AWS VPC vpc-0abcdef1234567890, then 'vpc-0abcdef1234567890' is the resourceId and AWS::EC2::VPC is the schemaName. After importing a component, you should ask the user if they want you to update the attributes of the imported component to use subscriptions to any existing components attributes - for example, an imported AWS::EC2::Subnet would be updated to have a subscription to the /resource_value/VpcId of the AWS::EC2::VPC that matches the imported VpcId attribute of the subnet.</usage>`;

const ImportComponentInputSchemaRaw = {
  changeSetId: z.string().describe(
    "The change set to import the component in; components cannot be imported on the HEAD change set",
  ),
  schemaName: z.string().describe("the schema name of the component to import"),
  resourceId: z.string().describe(
    "the resource id to import; should map to a unique id generated by the component on creation",
  ),
  attributes: AttributesSchema.describe(
    "attributes to set on the component before import; for AWS resources, this *must* include setting a subscription for the AWS Credential, and either a raw value or a subscription for /domain/extra/Region as well",
  ),
};

const ImportComponentOutputSchemaRaw = {
  status: z.enum(["success", "failure"]),
  errorMessage: z.string().optional().describe(
    "If the status is failure, the error message will contain information about what went wrong",
  ),
  data: z.object({
    componentId: z.string().describe("the component id"),
    componentName: z.string().describe("the components name"),
    schemaName: z.string().describe("the schema for the component"),
    funcRunId: z.string().nullable().optional().describe(
      "the function run id for this management function; useful for debugging failure",
    ),
  }),
};
const ImportComponentOutputSchema = z.object(
  ImportComponentOutputSchemaRaw,
);

type ImportComponentResult = z.infer<
  typeof ImportComponentOutputSchema
>["data"];

export function componentImportTool(server: McpServer) {
  server.registerTool(
    name,
    {
      title,
      description: generateDescription(
        description,
        "componentDiscoverResponse",
        ImportComponentOutputSchema,
      ),
      inputSchema: ImportComponentInputSchemaRaw,
      outputSchema: ImportComponentOutputSchemaRaw,
    },
    async (
      { changeSetId, schemaName, resourceId, attributes },
    ): Promise<CallToolResult> => {
      if (schemaName.startsWith("AWS")) {
        let hasCredential = false;
        let hasRegion = false;
        for (const path of Object.keys(attributes)) {
          if (path == "/domain/extra/Region") {
            hasRegion = true;
          }
          if (path == "/secrets/AWS Credential") {
            hasCredential = true;
          }
        }
        if (!hasCredential || !hasRegion) {
          return errorResponse({
            response: { status: "bad prereq", data: {} },
            message:
              `This is an AWS resource, and to import it we must have /domain/extra/Region set to a valid value or subscription, and /secrets/AWS Credential set to a subscription.`,
          });
        }
      }
      const siApi = new ComponentsApi(apiConfig);
      try {
        const response = await siApi.createComponent({
          workspaceId: WORKSPACE_ID,
          changeSetId: changeSetId,
          createComponentV1Request: {
            name: resourceId,
            resourceId,
            schemaName,
            attributes,
          },
        });
        const result: Record<string, string> = {
          componentId: response.data.component.id,
          componentName: response.data.component.name,
          schemaName: schemaName,
        };
        try {
          const importResponse = await siApi.executeManagementFunction({
            workspaceId: WORKSPACE_ID,
            changeSetId,
            componentId: result["componentId"],
            executeManagementFunctionV1Request: {
              managementFunction: { function: "Import from AWS" },
            },
          });

          let importState = "Pending";
          const retrySleepInMs = 1000;
          const retryMaxCount = 120;
          let currentCount = 0;

          const mgmtApi = new ManagementFuncsApi(apiConfig);
          while (
            (importState == "Pending" || importState == "Executing" ||
              importState == "Operating") && currentCount <= retryMaxCount
          ) {
            if (currentCount != 0) {
              sleep(retrySleepInMs);
            }
            try {
              const status = await mgmtApi.getManagementFuncRunState({
                workspaceId: WORKSPACE_ID,
                changeSetId,
                managementFuncJobStateId:
                  importResponse.data.managementFuncJobStateId,
              });
              importState = status.data.state;
              result["funcRunId"] = status.data.funcRunId;
              currentCount += 1;
            } catch (error) {
              return errorResponse({
                message: `error fetching management function state: ${
                  JSON.stringify(error, null, 2)
                }`,
              });
            }
          }
          if (currentCount > retryMaxCount) {
            return successResponse(
              result,
              "The import function is still in progress; use the funcRunId to find out more",
            );
          } else if (importState == "Failure") {
            return errorResponse({
              response: {
                status: "failed",
                data: result,
              },
              message:
                `failed to import ${schemaName} with resourceId ${resourceId}; see funcRunId ${
                  result["funcRunId"]
                } with the func-run-get tool for more information`,
            });
          } else {
            return successResponse(result);
          }
        } catch (error) {
          return errorResponse(error);
        }
      } catch (error) {
        return errorResponse(error);
      }
    },
  );
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
