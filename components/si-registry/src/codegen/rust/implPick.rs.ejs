pub async fn pick_by_expressions(
    db: &si_data::Db,
    items: Vec<si_data::DataQueryItems>,
    boolean_term: si_data::DataQueryBooleanTerm,
) -> si_data::Result<Self> {
    let query = si_data::DataQuery {
        items,
        boolean_term: boolean_term as i32,
        ..Default::default()
    };

    let mut check_result: si_data::ListResult<Self> =
        db.list(&Some(query), 1, "", 0, "global", "").await?;
    if check_result.len() == 1 {
        return Ok(check_result.items.pop().unwrap());
    } else {
        return Err(si_data::DataError::PickComponent("a match was not found".to_string()));
    }
}

pub async fn pick_by_string_field<F, V>(
    db: &si_data::Db,
    field: F,
    value: V,
) -> si_data::Result<Option<Self>>
where
    F: Into<String> + Send,
    V: Into<String> + Send,
{
    let value = value.into();
    let field = field.into();

    if value != "" {
        let query = si_data::DataQuery::generate_for_string(
            field.clone(),
            si_data::DataQueryItemsExpressionComparison::Equals,
            value.clone(),
        );
        let mut check_result: si_data::ListResult<Self> =
            db.list(&Some(query), 1, "", 0, "global", "").await?;
        if check_result.len() == 1 {
            return Ok(Some(check_result.items.pop().unwrap()));
        } else {
            return Err(si_data::DataError::PickComponent(format!(
                "{}={} must match exactly, and was not found",
                field, value
            )));
        }
    }
    Ok(None)
}

pub async fn pick_by_component_name(
    db: &si_data::Db,
    req: &<%- fmt.componentConstraintsName() %>,
) -> si_data::Result<Option<(<%- fmt.componentConstraintsName() %>, Self)>> {
    match &req.component_name {
        Some(name) => {
            match Self::pick_by_string_field(db, "name", name).await? {
                Some(component) => Ok(Some((<%- fmt.componentConstraintsName() %>::default(), component))),
                None => Ok(None),
            }
        }
        None => Ok(None),
    }
}

pub async fn pick_by_component_display_name(
    db: &si_data::Db,
    req: &<%- fmt.componentConstraintsName() %>,
) -> si_data::Result<Option<(<%- fmt.componentConstraintsName() %>, Self)>> {
    match &req.component_display_name {
        Some(display_name) => {
            match Self::pick_by_string_field(db, "displayName", display_name)
                .await?
            {
                Some(component) => Ok(Some((<%- fmt.componentConstraintsName() %>::default(), component))),
                None => Ok(None),
            }
        }
        None => Ok(None),
    }
}
