impl si_data::Storable for <%- fmt.structName() %> {
    fn type_name() -> &'static str {
        "<%- fmt.typeName() %>"
    }

    fn set_type_name(&mut self) {
        if self.si_storable.is_none() {
            self.si_storable = Some(Default::default());
        }

        let si_storable = self.si_storable
            .as_mut()
            .expect("<%- fmt.structName() %>.si_storable \
                has been set or initialized");
        si_storable.type_name = Some(Self::type_name().to_string());
    }

    fn id(&self) -> si_data::Result<&str> {
        self.id
            .as_ref()
            .map(String::as_str)
            .ok_or_else(|| si_data::DataError::RequiredField("id".to_string()))
    }

    fn set_id(&mut self, id: impl Into<String>) {
        self.id = Some(id.into());
    }

    fn change_set_id(&self) -> si_data::Result<Option<&str>> {
        Ok(self.si_storable
            .as_ref()
            .ok_or_else(|| si_data::DataError::RequiredField("si_storable".to_string()))?
            .change_set_id
            .as_ref()
            .map(String::as_str))
    }

    fn set_change_set_entry_count(&mut self, entry_count: u64) -> si_data::Result<()> {
        self.si_storable
            .as_mut()
            .ok_or_else(|| si_data::DataError::RequiredField("si_storable".to_string()))?
            .change_set_entry_count
            .replace(entry_count);
        Ok(())
     }

    // How this should work:
    //
    //  * Do we have an ID?
    //      * Are we in a change set?
    //          * Update the order
    //          * Set the new ID
    //      * keep the current ID
    //  * We don't have an ID
    //      * Generate a new real object id
    //          * Set the item ID to it
    //      * Make the change-set id, and set that as the real one.
    //
    // This needs to possibly error now!
    fn generate_id(&mut self) {
        if let Ok(_current_id) = self.id() {
            if let Some(change_set_id) = self
                .si_storable
                .as_ref()
                .map(|si_storable| si_storable.change_set_id.as_ref())
                .flatten()
            {
                let real_id = self
                    .si_storable
                    .as_ref()
                    .map(|si_storable| si_storable.item_id.as_ref())
                    .flatten()
                    .expect("must have a real item_id");
                let change_set_entry_count = self
                    .si_storable
                    .as_ref()
                    .map(|si_storable| si_storable.change_set_entry_count.as_ref())
                    .flatten()
                    .expect("must have a change_set_entry_count");
                let new_id = format!("{}:{}:{}", change_set_id, change_set_entry_count, real_id);
                self.set_id(new_id);
            }
        } else {
            let real_id = format!("{}:{}", Self::type_name(), si_data::uuid_string(),);
            self.si_storable
                .as_mut()
                .map(|si_storable| si_storable.item_id = Some(real_id.clone()));
            if let Some(change_set_id) = self
                .si_storable
                .as_ref()
                .map(|si_storable| si_storable.change_set_id.as_ref())
                .flatten()
            {
                let change_set_entry_count = self
                    .si_storable
                    .as_ref()
                    .map(|si_storable| si_storable.change_set_entry_count.as_ref())
                    .flatten()
                    .expect("must have a change_set_entry_count");
                let new_id = format!("{}:{}:{}", change_set_id, change_set_entry_count, real_id);
                self.set_id(new_id);
            } else {
                self.set_id(real_id);
            }
        }
    }

    fn natural_key(&self) -> si_data::Result<Option<&str>> {
    <%_ if (fmt.isEntityEventObject() || fmt.isEntityObject()) { _%>
        Ok(None)
    <%_ } else { _%>
        Ok(self.si_storable
            .as_ref()
            .ok_or_else(|| si_data::DataError::RequiredField("si_storable".to_string()))?
            .natural_key
            .as_ref()
            .map(String::as_str))
    <%_ } _%>
    }

    fn set_natural_key(&mut self) -> si_data::Result<()> {
    <%_ if (fmt.isEntityEventObject() || fmt.isEntityObject()) { _%>
        Ok(())
    <%_ } else { _%>
        let natural_key = format!(
            "{}:{}:{}",
            self.tenant_ids()?.first().ok_or_else(|| si_data::DataError::MissingTenantIds)?,
            Self::type_name(),
            self.<%- fmt.naturalKey() %>
                .as_ref()
                .ok_or_else(|| si_data::DataError::RequiredField("<%- fmt.naturalKey() %>".to_string()))?,
        );

        if self.si_storable.is_none() {
            self.si_storable = Some(Default::default());
        }

        let si_storable = self.si_storable
            .as_mut()
            .expect("<%- fmt.structName() %>.si_storable \
                has been set or initialized");
        si_storable.natural_key = Some(natural_key);

        Ok(())
      <%_ } _%>
    }

    fn tenant_ids(&self) -> si_data::Result<&[String]> {
        Ok(self.si_storable
            .as_ref()
            .ok_or_else(|| si_data::DataError::RequiredField("si_storable".to_string()))?
            .tenant_ids
            .as_slice())
    }

    fn add_to_tenant_ids(&mut self, id: impl Into<String>) {
        if self.si_storable.is_none() {
            self.si_storable = Some(Default::default());
        }

        let si_storable = self.si_storable
            .as_mut()
            .expect("<%- fmt.structName() %>.si_storable \
                has been set or initialized");
        si_storable.tenant_ids.push(id.into());
    }

    fn validate(&self) -> si_data::error::Result<()> {
        <%- fmt.storableValidateFunction() %>

        Ok(())
    }

    fn referential_fields(&self) -> Vec<si_data::Reference> {
        <%- fmt.storableReferentialFieldsFunction() %>
    }

    fn order_by_fields() -> Vec<&'static str> {
      <%- fmt.storableOrderByFieldsFunction() %>
    }
}
