/* tslint:disable */
/* eslint-disable */
/**
 * System Initiative API
 * The API Server for interacting with a System Initiative workspace
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * @type ActionReference
 * Reference to a management function by either name or ID. This allows clients to use the more human-friendly name approach or the more precise ID approach when working with actions.
 * @export
 */
export type ActionReference = ActionReferenceOneOf | ActionReferenceOneOf1;

/**
 * 
 * @export
 * @interface ActionReferenceOneOf
 */
export interface ActionReferenceOneOf {
    /**
     * 
     * @type {string}
     * @memberof ActionReferenceOneOf
     */
    'function': string;
}
/**
 * 
 * @export
 * @interface ActionReferenceOneOf1
 */
export interface ActionReferenceOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ActionReferenceOneOf1
     */
    'actionPrototypeId': string;
}
/**
 * 
 * @export
 * @interface ActionV1RequestPath
 */
export interface ActionV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof ActionV1RequestPath
     */
    'action_id': string;
}
/**
 * 
 * @export
 * @interface ActionViewV1
 */
export interface ActionViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'componentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'funcRunId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'originatingChangeSetId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'prototypeId': string;
    /**
     * 
     * @type {string}
     * @memberof ActionViewV1
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface AddActionV1Request
 */
export interface AddActionV1Request {
    /**
     * 
     * @type {ActionReference}
     * @memberof AddActionV1Request
     */
    'action': ActionReference;
}
/**
 * 
 * @export
 * @interface AddActionV1Response
 */
export interface AddActionV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof AddActionV1Response
     */
    'success': boolean;
}
/**
 * Standard error response format for v1 API
 * @export
 * @interface ApiError
 */
export interface ApiError {
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'code'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ApiError
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ApiError
     */
    'statusCode': number;
}
/**
 * Standard success response format for v1 API
 * @export
 * @interface ApiSuccessString
 */
export interface ApiSuccessString {
    /**
     * 
     * @type {string}
     * @memberof ApiSuccessString
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface BuildingResponseV1
 */
export interface BuildingResponseV1 {
    /**
     * 
     * @type {number}
     * @memberof BuildingResponseV1
     */
    'estimatedCompletionSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof BuildingResponseV1
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof BuildingResponseV1
     */
    'retryAfterSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof BuildingResponseV1
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface CancelActionV1Response
 */
export interface CancelActionV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof CancelActionV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface ChangeSetViewV1
 */
export interface ChangeSetViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ChangeSetViewV1
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ChangeSetViewV1
     */
    'isHead': boolean;
    /**
     * 
     * @type {string}
     * @memberof ChangeSetViewV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ChangeSetViewV1
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface ComponentDetailsV1
 */
export interface ComponentDetailsV1 {
    /**
     * 
     * @type {any}
     * @memberof ComponentDetailsV1
     */
    'codegen'?: any;
    /**
     * 
     * @type {string}
     * @memberof ComponentDetailsV1
     */
    'componentId': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentDetailsV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentDetailsV1
     */
    'schemaName': string;
}
/**
 * @type ComponentPropKey
 * @export
 */
export type ComponentPropKey = string;

/**
 * 
 * @export
 * @interface ComponentPropViewV1
 */
export interface ComponentPropViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ComponentPropViewV1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentPropViewV1
     */
    'path': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentPropViewV1
     */
    'propId': string;
    /**
     * 
     * @type {any}
     * @memberof ComponentPropViewV1
     */
    'value'?: any;
}
/**
 * @type ComponentReference
 * @export
 */
export type ComponentReference = ComponentReferenceOneOf | ComponentReferenceOneOf1;

/**
 * 
 * @export
 * @interface ComponentReferenceOneOf
 */
export interface ComponentReferenceOneOf {
    /**
     * 
     * @type {string}
     * @memberof ComponentReferenceOneOf
     */
    'component': string;
}
/**
 * 
 * @export
 * @interface ComponentReferenceOneOf1
 */
export interface ComponentReferenceOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ComponentReferenceOneOf1
     */
    'componentId': string;
}
/**
 * Component data in search results.
 * @export
 * @interface ComponentSearchResult
 */
export interface ComponentSearchResult {
    /**
     * 
     * @type {string}
     * @memberof ComponentSearchResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentSearchResult
     */
    'name': string;
    /**
     * 
     * @type {ComponentSearchResultSchema}
     * @memberof ComponentSearchResult
     */
    'schema': ComponentSearchResultSchema;
}
/**
 * The schema for a component in search results.
 * @export
 * @interface ComponentSearchResultSchema
 */
export interface ComponentSearchResultSchema {
    /**
     * 
     * @type {string}
     * @memberof ComponentSearchResultSchema
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ComponentV1RequestPath
 */
export interface ComponentV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof ComponentV1RequestPath
     */
    'component_id': string;
}
/**
 * 
 * @export
 * @interface ComponentViewV1
 */
export interface ComponentViewV1 {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ComponentViewV1
     */
    'attributes': { [key: string]: any; };
    /**
     * 
     * @type {boolean}
     * @memberof ComponentViewV1
     */
    'canBeUpgraded': boolean;
    /**
     * 
     * @type {Array<ConnectionViewV1>}
     * @memberof ComponentViewV1
     */
    'connections': Array<ConnectionViewV1>;
    /**
     * 
     * @type {Array<ComponentPropViewV1>}
     * @memberof ComponentViewV1
     */
    'domainProps': Array<ComponentPropViewV1>;
    /**
     * 
     * @type {string}
     * @memberof ComponentViewV1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentViewV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentViewV1
     */
    'resourceId': string;
    /**
     * 
     * @type {Array<ComponentPropViewV1>}
     * @memberof ComponentViewV1
     */
    'resourceProps': Array<ComponentPropViewV1>;
    /**
     * 
     * @type {string}
     * @memberof ComponentViewV1
     */
    'schemaId': string;
    /**
     * 
     * @type {string}
     * @memberof ComponentViewV1
     */
    'schemaVariantId': string;
    /**
     * 
     * @type {boolean}
     * @memberof ComponentViewV1
     */
    'toDelete': boolean;
    /**
     * 
     * @type {Array<ViewV1>}
     * @memberof ComponentViewV1
     */
    'views': Array<ViewV1>;
}
/**
 * @type ConnectionViewV1
 * @export
 */
export type ConnectionViewV1 = ConnectionViewV1OneOf | ConnectionViewV1OneOf1;

/**
 * 
 * @export
 * @interface ConnectionViewV1OneOf
 */
export interface ConnectionViewV1OneOf {
    /**
     * 
     * @type {ManagingConnectionViewV1}
     * @memberof ConnectionViewV1OneOf
     */
    'managing': ManagingConnectionViewV1;
}
/**
 * 
 * @export
 * @interface ConnectionViewV1OneOf1
 */
export interface ConnectionViewV1OneOf1 {
    /**
     * 
     * @type {ManagedByConnectionViewV1}
     * @memberof ConnectionViewV1OneOf1
     */
    'managedBy': ManagedByConnectionViewV1;
}
/**
 * 
 * @export
 * @interface CreateChangeSetV1Request
 */
export interface CreateChangeSetV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateChangeSetV1Request
     */
    'changeSetName': string;
}
/**
 * 
 * @export
 * @interface CreateChangeSetV1Response
 */
export interface CreateChangeSetV1Response {
    /**
     * 
     * @type {ChangeSetViewV1}
     * @memberof CreateChangeSetV1Response
     */
    'changeSet': ChangeSetViewV1;
}
/**
 * 
 * @export
 * @interface CreateComponentV1Request
 */
export interface CreateComponentV1Request {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof CreateComponentV1Request
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {ComponentReference}
     * @memberof CreateComponentV1Request
     */
    'managedBy'?: ComponentReference;
    /**
     * 
     * @type {string}
     * @memberof CreateComponentV1Request
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateComponentV1Request
     */
    'resourceId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateComponentV1Request
     */
    'schemaName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateComponentV1Request
     */
    'viewName'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateComponentV1Response
 */
export interface CreateComponentV1Response {
    /**
     * 
     * @type {ComponentViewV1}
     * @memberof CreateComponentV1Response
     */
    'component': ComponentViewV1;
}
/**
 * 
 * @export
 * @interface CreateSchemaV1Request
 */
export interface CreateSchemaV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'category'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSchemaV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateSecretV1Request
 */
export interface CreateSecretV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateSecretV1Request
     */
    'definitionName': string;
    /**
     * 
     * @type {string}
     * @memberof CreateSecretV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateSecretV1Request
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateSecretV1Request
     */
    'rawData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface CreateSecretV1Response
 */
export interface CreateSecretV1Response {
    /**
     * 
     * @type {SecretV1}
     * @memberof CreateSecretV1Response
     */
    'secret': SecretV1;
}
/**
 * 
 * @export
 * @interface CreateVariantActionFuncV1Request
 */
export interface CreateVariantActionFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Request
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Request
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateVariantActionFuncV1Response
 */
export interface CreateVariantActionFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantActionFuncV1Response
     */
    'funcId': string;
}
/**
 * 
 * @export
 * @interface CreateVariantAuthenticationFuncV1Request
 */
export interface CreateVariantAuthenticationFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantAuthenticationFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantAuthenticationFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantAuthenticationFuncV1Request
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantAuthenticationFuncV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateVariantAuthenticationFuncV1Response
 */
export interface CreateVariantAuthenticationFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantAuthenticationFuncV1Response
     */
    'funcId': string;
}
/**
 * 
 * @export
 * @interface CreateVariantCodegenFuncV1Request
 */
export interface CreateVariantCodegenFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantCodegenFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantCodegenFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantCodegenFuncV1Request
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantCodegenFuncV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateVariantCodegenFuncV1Response
 */
export interface CreateVariantCodegenFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantCodegenFuncV1Response
     */
    'funcId': string;
}
/**
 * 
 * @export
 * @interface CreateVariantManagementFuncV1Request
 */
export interface CreateVariantManagementFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantManagementFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantManagementFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantManagementFuncV1Request
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantManagementFuncV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateVariantManagementFuncV1Response
 */
export interface CreateVariantManagementFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantManagementFuncV1Response
     */
    'funcId': string;
}
/**
 * 
 * @export
 * @interface CreateVariantQualificationFuncV1Request
 */
export interface CreateVariantQualificationFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantQualificationFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantQualificationFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantQualificationFuncV1Request
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateVariantQualificationFuncV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CreateVariantQualificationFuncV1Response
 */
export interface CreateVariantQualificationFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof CreateVariantQualificationFuncV1Response
     */
    'funcId': string;
}
/**
 * 
 * @export
 * @interface DeleteChangeSetV1Response
 */
export interface DeleteChangeSetV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteChangeSetV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface DeleteComponentV1Response
 */
export interface DeleteComponentV1Response {
    /**
     * 
     * @type {string}
     * @memberof DeleteComponentV1Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface DeleteSecretV1Response
 */
export interface DeleteSecretV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeleteSecretV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface DuplicateComponentsV1Request
 */
export interface DuplicateComponentsV1Request {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof DuplicateComponentsV1Request
     */
    'components': Array<Array<string>>;
    /**
     * 
     * @type {string}
     * @memberof DuplicateComponentsV1Request
     */
    'prefix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DuplicateComponentsV1Request
     */
    'viewName'?: string | null;
}
/**
 * 
 * @export
 * @interface DuplicateComponentsV1Response
 */
export interface DuplicateComponentsV1Response {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof DuplicateComponentsV1Response
     */
    'components': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface EraseComponentV1Response
 */
export interface EraseComponentV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof EraseComponentV1Response
     */
    'status': boolean;
}
/**
 * 
 * @export
 * @interface ErrorDetail
 */
export interface ErrorDetail {
    /**
     * 
     * @type {number}
     * @memberof ErrorDetail
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorDetail
     */
    'message': string;
    /**
     * 
     * @type {number}
     * @memberof ErrorDetail
     */
    'status_code': number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {ErrorDetail}
     * @memberof ErrorResponse
     */
    'error': ErrorDetail;
}
/**
 * 
 * @export
 * @interface ExecuteManagementFunctionV1Request
 */
export interface ExecuteManagementFunctionV1Request {
    /**
     * 
     * @type {ManagementFunctionReference}
     * @memberof ExecuteManagementFunctionV1Request
     */
    'managementFunction': ManagementFunctionReference;
    /**
     * 
     * @type {string}
     * @memberof ExecuteManagementFunctionV1Request
     */
    'viewName'?: string | null;
}
/**
 * 
 * @export
 * @interface ExecuteManagementFunctionV1Response
 */
export interface ExecuteManagementFunctionV1Response {
    /**
     * 
     * @type {string}
     * @memberof ExecuteManagementFunctionV1Response
     * @deprecated
     */
    'funcRunId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExecuteManagementFunctionV1Response
     */
    'managementFuncJobStateId': string;
    /**
     * 
     * @type {string}
     * @memberof ExecuteManagementFunctionV1Response
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExecuteManagementFunctionV1Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface FindComponentV1Params
 */
export interface FindComponentV1Params {
    /**
     * 
     * @type {string}
     * @memberof FindComponentV1Params
     */
    'component'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindComponentV1Params
     */
    'componentId'?: string | null;
}
/**
 * 
 * @export
 * @interface FindSchemaV1Params
 */
export interface FindSchemaV1Params {
    /**
     * 
     * @type {string}
     * @memberof FindSchemaV1Params
     */
    'schema'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FindSchemaV1Params
     */
    'schemaId'?: string | null;
}
/**
 * 
 * @export
 * @interface FindSchemaV1Response
 */
export interface FindSchemaV1Response {
    /**
     * 
     * @type {string}
     * @memberof FindSchemaV1Response
     */
    'category'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof FindSchemaV1Response
     */
    'installed': boolean;
    /**
     * 
     * @type {string}
     * @memberof FindSchemaV1Response
     */
    'schemaId': string;
    /**
     * 
     * @type {string}
     * @memberof FindSchemaV1Response
     */
    'schemaName': string;
}
/**
 * 
 * @export
 * @interface ForceApplyChangeSetV1Response
 */
export interface ForceApplyChangeSetV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof ForceApplyChangeSetV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface FuncRunLogViewV1
 */
export interface FuncRunLogViewV1 {
    /**
     * 
     * @type {string}
     * @memberof FuncRunLogViewV1
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof FuncRunLogViewV1
     */
    'finalized': boolean;
    /**
     * 
     * @type {string}
     * @memberof FuncRunLogViewV1
     */
    'funcRunId': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunLogViewV1
     */
    'id': string;
    /**
     * 
     * @type {Array<object>}
     * @memberof FuncRunLogViewV1
     */
    'logs': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof FuncRunLogViewV1
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface FuncRunV1RequestPath
 */
export interface FuncRunV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof FuncRunV1RequestPath
     */
    'func_run_id': string;
}
/**
 * 
 * @export
 * @interface FuncRunViewV1
 */
export interface FuncRunViewV1 {
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionKind'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionOriginatingChangeSetId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionOriginatingChangeSetName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionPrototypeId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'actionResultState'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'attributeValueId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'backendKind': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'backendResponseType': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'componentId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'componentName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'createdAt': string;
    /**
     * 
     * @type {any}
     * @memberof FuncRunViewV1
     */
    'functionArgs': any;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionCodeBase64': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionDescription'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionDisplayName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionKind': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionLink'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'functionName': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'id': string;
    /**
     * 
     * @type {FuncRunLogViewV1}
     * @memberof FuncRunViewV1
     */
    'logs'?: FuncRunLogViewV1 | null;
    /**
     * 
     * @type {any}
     * @memberof FuncRunViewV1
     */
    'resultValue'?: any;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'schemaName'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof FuncRunViewV1
     */
    'updatedAt': string;
}
/**
 * 
 * @export
 * @interface GenerateTemplateV1Request
 */
export interface GenerateTemplateV1Request {
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Request
     */
    'assetName': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Request
     */
    'category'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GenerateTemplateV1Request
     */
    'componentIds': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Request
     */
    'funcName': string;
}
/**
 * 
 * @export
 * @interface GenerateTemplateV1Response
 */
export interface GenerateTemplateV1Response {
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Response
     */
    'funcId': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Response
     */
    'schemaId': string;
    /**
     * 
     * @type {string}
     * @memberof GenerateTemplateV1Response
     */
    'schemaVariantId': string;
}
/**
 * 
 * @export
 * @interface GetActionsV1Response
 */
export interface GetActionsV1Response {
    /**
     * 
     * @type {Array<ActionViewV1>}
     * @memberof GetActionsV1Response
     */
    'actions': Array<ActionViewV1>;
}
/**
 * 
 * @export
 * @interface GetChangeSetV1Response
 */
export interface GetChangeSetV1Response {
    /**
     * 
     * @type {ChangeSetViewV1}
     * @memberof GetChangeSetV1Response
     */
    'changeSet': ChangeSetViewV1;
}
/**
 * 
 * @export
 * @interface GetComponentV1Response
 */
export interface GetComponentV1Response {
    /**
     * 
     * @type {Array<GetComponentV1ResponseActionFunction>}
     * @memberof GetComponentV1Response
     */
    'actionFunctions': Array<GetComponentV1ResponseActionFunction>;
    /**
     * 
     * @type {ComponentViewV1}
     * @memberof GetComponentV1Response
     */
    'component': ComponentViewV1;
    /**
     * 
     * @type {Array<GetComponentV1ResponseManagementFunction>}
     * @memberof GetComponentV1Response
     */
    'managementFunctions': Array<GetComponentV1ResponseManagementFunction>;
}
/**
 * 
 * @export
 * @interface GetComponentV1ResponseActionFunction
 */
export interface GetComponentV1ResponseActionFunction {
    /**
     * 
     * @type {string}
     * @memberof GetComponentV1ResponseActionFunction
     */
    'funcName': string;
    /**
     * 
     * @type {string}
     * @memberof GetComponentV1ResponseActionFunction
     */
    'prototypeId': string;
}
/**
 * 
 * @export
 * @interface GetComponentV1ResponseManagementFunction
 */
export interface GetComponentV1ResponseManagementFunction {
    /**
     * 
     * @type {string}
     * @memberof GetComponentV1ResponseManagementFunction
     */
    'funcName': string;
    /**
     * 
     * @type {string}
     * @memberof GetComponentV1ResponseManagementFunction
     */
    'managementPrototypeId': string;
}
/**
 * 
 * @export
 * @interface GetFuncRunV1Response
 */
export interface GetFuncRunV1Response {
    /**
     * 
     * @type {FuncRunViewV1}
     * @memberof GetFuncRunV1Response
     */
    'funcRun': FuncRunViewV1;
}
/**
 * 
 * @export
 * @interface GetFuncV1Response
 */
export interface GetFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'displayName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetFuncV1Response
     */
    'isLocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetFuncV1Response
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GetManagementFuncJobStateV1Response
 */
export interface GetManagementFuncJobStateV1Response {
    /**
     * 
     * @type {string}
     * @memberof GetManagementFuncJobStateV1Response
     */
    'funcRunId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetManagementFuncJobStateV1Response
     */
    'state': string;
}
/**
 * 
 * @export
 * @interface GetSchemaV1Response
 */
export interface GetSchemaV1Response {
    /**
     * 
     * @type {string}
     * @memberof GetSchemaV1Response
     */
    'defaultVariantId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaV1Response
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaV1Response
     */
    'schemaId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSchemaV1Response
     */
    'variantIds': Array<string>;
}
/**
 * 
 * @export
 * @interface GetSchemaVariantV1Response
 */
export interface GetSchemaVariantV1Response {
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'assetFuncId': string;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'color': string;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'displayName': string;
    /**
     * 
     * @type {PropSchemaV1}
     * @memberof GetSchemaVariantV1Response
     */
    'domainProps'?: PropSchemaV1 | null;
    /**
     * 
     * @type {boolean}
     * @memberof GetSchemaVariantV1Response
     */
    'installedFromUpstream': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSchemaVariantV1Response
     */
    'isDefaultVariant': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GetSchemaVariantV1Response
     */
    'isLocked': boolean;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'link'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSchemaVariantV1Response
     */
    'variantFuncIds': Array<string>;
    /**
     * 
     * @type {Array<SchemaVariantFunc>}
     * @memberof GetSchemaVariantV1Response
     */
    'variantFuncs': Array<SchemaVariantFunc>;
    /**
     * 
     * @type {string}
     * @memberof GetSchemaVariantV1Response
     */
    'variantId': string;
}
/**
 * 
 * @export
 * @interface HashMapValue
 */
export interface HashMapValue {
    /**
     * 
     * @type {SecretDefinitionV1}
     * @memberof HashMapValue
     */
    'definition': SecretDefinitionV1;
    /**
     * 
     * @type {Array<SecretV1>}
     * @memberof HashMapValue
     */
    'secrets': Array<SecretV1>;
}
/**
 * 
 * @export
 * @interface ListChangeSetV1Response
 */
export interface ListChangeSetV1Response {
    /**
     * 
     * @type {Array<object>}
     * @memberof ListChangeSetV1Response
     */
    'changeSets': Array<object>;
}
/**
 * 
 * @export
 * @interface ListComponentsV1Response
 */
export interface ListComponentsV1Response {
    /**
     * 
     * @type {Array<ComponentDetailsV1>}
     * @memberof ListComponentsV1Response
     */
    'componentDetails': Array<ComponentDetailsV1>;
    /**
     * 
     * @type {string}
     * @memberof ListComponentsV1Response
     */
    'nextCursor'?: string | null;
}
/**
 * 
 * @export
 * @interface ListSchemaV1Response
 */
export interface ListSchemaV1Response {
    /**
     * 
     * @type {string}
     * @memberof ListSchemaV1Response
     */
    'nextCursor'?: string | null;
    /**
     * 
     * @type {Array<SchemaResponse>}
     * @memberof ListSchemaV1Response
     */
    'schemas': Array<SchemaResponse>;
}
/**
 * 
 * @export
 * @interface ManageComponentV1Request
 */
export interface ManageComponentV1Request {
    /**
     * 
     * @type {string}
     * @memberof ManageComponentV1Request
     */
    'componentId': string;
}
/**
 * 
 * @export
 * @interface ManageComponentV1Response
 */
export interface ManageComponentV1Response {
    /**
     * 
     * @type {ComponentViewV1}
     * @memberof ManageComponentV1Response
     */
    'component': ComponentViewV1;
}
/**
 * 
 * @export
 * @interface ManagedByConnectionViewV1
 */
export interface ManagedByConnectionViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ManagedByConnectionViewV1
     */
    'componentId': string;
    /**
     * 
     * @type {string}
     * @memberof ManagedByConnectionViewV1
     */
    'componentName': string;
}
/**
 * 
 * @export
 * @interface ManagementFuncJobStateV1RequestPath
 */
export interface ManagementFuncJobStateV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof ManagementFuncJobStateV1RequestPath
     */
    'management_func_job_state_id': string;
}
/**
 * @type ManagementFunctionReference
 * Reference to a management function by either name or ID. This allows clients to use the more human-friendly name approach or the more precise ID approach when working with management functions.
 * @export
 */
export type ManagementFunctionReference = ManagementFunctionReferenceOneOf | ManagementFunctionReferenceOneOf1;

/**
 * 
 * @export
 * @interface ManagementFunctionReferenceOneOf
 */
export interface ManagementFunctionReferenceOneOf {
    /**
     * 
     * @type {string}
     * @memberof ManagementFunctionReferenceOneOf
     */
    'function': string;
}
/**
 * 
 * @export
 * @interface ManagementFunctionReferenceOneOf1
 */
export interface ManagementFunctionReferenceOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof ManagementFunctionReferenceOneOf1
     */
    'managementPrototypeId': string;
}
/**
 * 
 * @export
 * @interface ManagingConnectionViewV1
 */
export interface ManagingConnectionViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ManagingConnectionViewV1
     */
    'componentId': string;
    /**
     * 
     * @type {string}
     * @memberof ManagingConnectionViewV1
     */
    'componentName': string;
}
/**
 * Response for merge status
 * @export
 * @interface MergeStatusV1Response
 */
export interface MergeStatusV1Response {
    /**
     * 
     * @type {Array<MergeStatusV1ResponseAction>}
     * @memberof MergeStatusV1Response
     */
    'actions': Array<MergeStatusV1ResponseAction>;
    /**
     * 
     * @type {object}
     * @memberof MergeStatusV1Response
     */
    'changeSet': object;
}
/**
 * Action item in merge status response
 * @export
 * @interface MergeStatusV1ResponseAction
 */
export interface MergeStatusV1ResponseAction {
    /**
     * 
     * @type {MergeStatusV1ResponseActionComponent}
     * @memberof MergeStatusV1ResponseAction
     */
    'component'?: MergeStatusV1ResponseActionComponent | null;
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseAction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseAction
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseAction
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseAction
     */
    'state': string;
}
/**
 * Component details in action response
 * @export
 * @interface MergeStatusV1ResponseActionComponent
 */
export interface MergeStatusV1ResponseActionComponent {
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseActionComponent
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MergeStatusV1ResponseActionComponent
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface OutputLineViewV1
 */
export interface OutputLineViewV1 {
    /**
     * 
     * @type {string}
     * @memberof OutputLineViewV1
     */
    'executionId': string;
    /**
     * 
     * @type {string}
     * @memberof OutputLineViewV1
     */
    'group'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OutputLineViewV1
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof OutputLineViewV1
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof OutputLineViewV1
     */
    'stream': string;
    /**
     * 
     * @type {number}
     * @memberof OutputLineViewV1
     */
    'timestamp': number;
}
/**
 * 
 * @export
 * @interface PropSchemaV1
 */
export interface PropSchemaV1 {
    /**
     * 
     * @type {Array<PropSchemaV1>}
     * @memberof PropSchemaV1
     */
    'children'?: Array<PropSchemaV1> | null;
    /**
     * 
     * @type {any}
     * @memberof PropSchemaV1
     */
    'defaultValue'?: any;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'docLink'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PropSchemaV1
     */
    'hidden'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'propId': string;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'propType': string;
    /**
     * 
     * @type {string}
     * @memberof PropSchemaV1
     */
    'validationFormat'?: string | null;
}
/**
 * 
 * @export
 * @interface PurgeOpenChangeSetsV1Response
 */
export interface PurgeOpenChangeSetsV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof PurgeOpenChangeSetsV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface PutOnHoldActionV1Response
 */
export interface PutOnHoldActionV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof PutOnHoldActionV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface RequestApprovalChangeSetV1Response
 */
export interface RequestApprovalChangeSetV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof RequestApprovalChangeSetV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface RestoreComponentV1Response
 */
export interface RestoreComponentV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof RestoreComponentV1Response
     */
    'status': boolean;
}
/**
 * 
 * @export
 * @interface RetryActionV1Response
 */
export interface RetryActionV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof RetryActionV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface SchemaResponse
 */
export interface SchemaResponse {
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'category'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SchemaResponse
     */
    'installed': boolean;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'schemaId': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaResponse
     */
    'schemaName': string;
}
/**
 * 
 * @export
 * @interface SchemaV1RequestPath
 */
export interface SchemaV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof SchemaV1RequestPath
     */
    'schema_id': string;
}
/**
 * 
 * @export
 * @interface SchemaVariantFunc
 */
export interface SchemaVariantFunc {
    /**
     * 
     * @type {SchemaVariantFuncKind}
     * @memberof SchemaVariantFunc
     */
    'funcKind': SchemaVariantFuncKind;
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantFunc
     */
    'id': string;
}
/**
 * @type SchemaVariantFuncKind
 * @export
 */
export type SchemaVariantFuncKind = SchemaVariantFuncKindOneOf | SchemaVariantFuncKindOneOf1 | SchemaVariantFuncKindOneOf2;

/**
 * Action function; carries the specific `ActionKind`.
 * @export
 * @interface SchemaVariantFuncKindOneOf
 */
export interface SchemaVariantFuncKindOneOf {
    /**
     * Specific action kind
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf
     */
    'actionKind': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf
     */
    'kind': SchemaVariantFuncKindOneOfKindEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SchemaVariantFuncKindOneOfKindEnum {
    ACTION = 'action'
}

/**
 * Management function; carries the specific `ManagementFuncKind`.
 * @export
 * @interface SchemaVariantFuncKindOneOf1
 */
export interface SchemaVariantFuncKindOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf1
     */
    'kind': SchemaVariantFuncKindOneOf1KindEnum;
    /**
     * Specific management function kind
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf1
     */
    'managementFuncKind': string;
}

/**
    * @export
    * @enum {string}
    */
export enum SchemaVariantFuncKindOneOf1KindEnum {
    MANAGEMENT = 'management'
}

/**
 * Any other function; exposes the raw `FuncKind` category.
 * @export
 * @interface SchemaVariantFuncKindOneOf2
 */
export interface SchemaVariantFuncKindOneOf2 {
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf2
     */
    'funcKind': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantFuncKindOneOf2
     */
    'kind': SchemaVariantFuncKindOneOf2KindEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SchemaVariantFuncKindOneOf2KindEnum {
    OTHER = 'other'
}

/**
 * 
 * @export
 * @interface SchemaVariantV1RequestPath
 */
export interface SchemaVariantV1RequestPath {
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantV1RequestPath
     */
    'schema_id': string;
    /**
     * 
     * @type {string}
     * @memberof SchemaVariantV1RequestPath
     */
    'schema_variant_id': string;
}
/**
 * 
 * @export
 * @interface SearchComponentsV1Request
 */
export interface SearchComponentsV1Request {
    /**
     * 
     * @type {string}
     * @memberof SearchComponentsV1Request
     */
    'queryString'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchComponentsV1Request
     */
    'schemaCategory'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SearchComponentsV1Request
     */
    'schemaName'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof SearchComponentsV1Request
     */
    'upgradable'?: boolean | null;
}
/**
 * 
 * @export
 * @interface SearchComponentsV1Response
 */
export interface SearchComponentsV1Response {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof SearchComponentsV1Response
     */
    'components': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface SearchSchemasV1Request
 */
export interface SearchSchemasV1Request {
    /**
     * 
     * @type {string}
     * @memberof SearchSchemasV1Request
     */
    'category'?: string | null;
}
/**
 * 
 * @export
 * @interface SearchSchemasV1Response
 */
export interface SearchSchemasV1Response {
    /**
     * 
     * @type {Array<SchemaResponse>}
     * @memberof SearchSchemasV1Response
     */
    'schemas': Array<SchemaResponse>;
}
/**
 * 
 * @export
 * @interface SearchV1Request
 */
export interface SearchV1Request {
    /**
     * 
     * @type {string}
     * @memberof SearchV1Request
     */
    'q': string;
}
/**
 * 
 * @export
 * @interface SearchV1Response
 */
export interface SearchV1Response {
    /**
     * 
     * @type {Array<ComponentSearchResult>}
     * @memberof SearchV1Response
     */
    'components': Array<ComponentSearchResult>;
}
/**
 * 
 * @export
 * @interface SecretDefinitionV1
 */
export interface SecretDefinitionV1 {
    /**
     * 
     * @type {Array<SecretFormDataV1>}
     * @memberof SecretDefinitionV1
     */
    'formData': Array<SecretFormDataV1>;
    /**
     * 
     * @type {string}
     * @memberof SecretDefinitionV1
     */
    'secretDefinition': string;
}
/**
 * 
 * @export
 * @interface SecretFormDataV1
 */
export interface SecretFormDataV1 {
    /**
     * 
     * @type {string}
     * @memberof SecretFormDataV1
     */
    'kind': string;
    /**
     * 
     * @type {string}
     * @memberof SecretFormDataV1
     */
    'name': string;
}
/**
 * @type SecretPropKey
 * @export
 */
export type SecretPropKey = string;

/**
 * 
 * @export
 * @interface SecretV1
 */
export interface SecretV1 {
    /**
     * 
     * @type {string}
     * @memberof SecretV1
     */
    'definition': string;
    /**
     * 
     * @type {string}
     * @memberof SecretV1
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SecretV1
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SecretV1
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SourceViewV1
 */
export interface SourceViewV1 {
    /**
     * 
     * @type {string}
     * @memberof SourceViewV1
     */
    'component': string;
    /**
     * 
     * @type {string}
     * @memberof SourceViewV1
     */
    'propPath': string;
}
/**
 * 
 * @export
 * @interface SystemStatusResponse
 */
export interface SystemStatusResponse {
    /**
     * 
     * @type {string}
     * @memberof SystemStatusResponse
     */
    'API Documentation': string;
}
/**
 * 
 * @export
 * @interface UnlockFuncV1Request
 */
export interface UnlockFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof UnlockFuncV1Request
     */
    'schemaVariantId': string;
}
/**
 * 
 * @export
 * @interface UnlockFuncV1Response
 */
export interface UnlockFuncV1Response {
    /**
     * 
     * @type {string}
     * @memberof UnlockFuncV1Response
     */
    'unlockedFuncId': string;
}
/**
 * 
 * @export
 * @interface UnlockedSchemaV1Response
 */
export interface UnlockedSchemaV1Response {
    /**
     * 
     * @type {string}
     * @memberof UnlockedSchemaV1Response
     */
    'schemaId': string;
    /**
     * 
     * @type {GetSchemaVariantV1Response}
     * @memberof UnlockedSchemaV1Response
     */
    'unlockedVariant': GetSchemaVariantV1Response;
    /**
     * 
     * @type {string}
     * @memberof UnlockedSchemaV1Response
     */
    'unlockedVariantId': string;
}
/**
 * 
 * @export
 * @interface UpdateComponentV1Request
 */
export interface UpdateComponentV1Request {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateComponentV1Request
     */
    'attributes'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof UpdateComponentV1Request
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateComponentV1Request
     */
    'resourceId'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof UpdateComponentV1Request
     */
    'secrets'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UpdateComponentV1Response
 */
export interface UpdateComponentV1Response {
    /**
     * 
     * @type {ComponentViewV1}
     * @memberof UpdateComponentV1Response
     */
    'component': ComponentViewV1;
}
/**
 * 
 * @export
 * @interface UpdateFuncV1Request
 */
export interface UpdateFuncV1Request {
    /**
     * 
     * @type {string}
     * @memberof UpdateFuncV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFuncV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateFuncV1Request
     */
    'displayName'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateFuncV1Response
 */
export interface UpdateFuncV1Response {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFuncV1Response
     */
    'success': boolean;
}
/**
 * 
 * @export
 * @interface UpdateSchemaVariantV1Request
 */
export interface UpdateSchemaVariantV1Request {
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSchemaVariantV1Request
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpdateSecretV1Request
 */
export interface UpdateSecretV1Request {
    /**
     * 
     * @type {string}
     * @memberof UpdateSecretV1Request
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UpdateSecretV1Request
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSecretV1Request
     */
    'name': string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UpdateSecretV1Request
     */
    'rawData'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface UpdateSecretV1Response
 */
export interface UpdateSecretV1Response {
    /**
     * 
     * @type {SecretV1}
     * @memberof UpdateSecretV1Response
     */
    'secret': SecretV1;
}
/**
 * 
 * @export
 * @interface UpgradeComponentV1Response
 */
export interface UpgradeComponentV1Response {
    /**
     * 
     * @type {ComponentViewV1}
     * @memberof UpgradeComponentV1Response
     */
    'component': ComponentViewV1;
}
/**
 * 
 * @export
 * @interface ViewV1
 */
export interface ViewV1 {
    /**
     * 
     * @type {string}
     * @memberof ViewV1
     */
    'id': string;
    /**
     * 
     * @type {boolean}
     * @memberof ViewV1
     */
    'isDefault': boolean;
    /**
     * 
     * @type {string}
     * @memberof ViewV1
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface WhoamiResponse
 */
export interface WhoamiResponse {
    /**
     * 
     * @type {object}
     * @memberof WhoamiResponse
     */
    'token': object;
    /**
     * 
     * @type {string}
     * @memberof WhoamiResponse
     */
    'userEmail': string;
    /**
     * 
     * @type {string}
     * @memberof WhoamiResponse
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof WhoamiResponse
     */
    'workspaceId': string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove queued action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAction: async (workspaceId: string, changeSetId: string, actionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('cancelAction', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('cancelAction', 'changeSetId', changeSetId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('cancelAction', 'actionId', actionId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/actions/{action_id}/cancel`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List queued actions
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getActions', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getActions', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/actions`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Put action on-hold
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOnHold: async (workspaceId: string, changeSetId: string, actionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('putOnHold', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('putOnHold', 'changeSetId', changeSetId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('putOnHold', 'actionId', actionId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/actions/{action_id}/put_on_hold`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retry action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryAction: async (workspaceId: string, changeSetId: string, actionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('retryAction', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('retryAction', 'changeSetId', changeSetId)
            // verify required parameter 'actionId' is not null or undefined
            assertParamExists('retryAction', 'actionId', actionId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/actions/{action_id}/retry`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"action_id"}}`, encodeURIComponent(String(actionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove queued action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelAction(workspaceId: string, changeSetId: string, actionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelActionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelAction(workspaceId, changeSetId, actionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.cancelAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List queued actions
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActions(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetActionsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActions(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.getActions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Put action on-hold
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putOnHold(workspaceId: string, changeSetId: string, actionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PutOnHoldActionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putOnHold(workspaceId, changeSetId, actionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.putOnHold']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retry action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} actionId Action identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retryAction(workspaceId: string, changeSetId: string, actionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetryActionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retryAction(workspaceId, changeSetId, actionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActionsApi.retryAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove queued action
         * @param {ActionsApiCancelActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelAction(requestParameters: ActionsApiCancelActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelActionV1Response> {
            return localVarFp.cancelAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List queued actions
         * @param {ActionsApiGetActionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActions(requestParameters: ActionsApiGetActionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetActionsV1Response> {
            return localVarFp.getActions(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Put action on-hold
         * @param {ActionsApiPutOnHoldRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOnHold(requestParameters: ActionsApiPutOnHoldRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutOnHoldActionV1Response> {
            return localVarFp.putOnHold(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retry action
         * @param {ActionsApiRetryActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retryAction(requestParameters: ActionsApiRetryActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RetryActionV1Response> {
            return localVarFp.retryAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * 
     * @summary Remove queued action
     * @param {ActionsApiCancelActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    cancelAction(requestParameters: ActionsApiCancelActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelActionV1Response>;

    /**
     * 
     * @summary List queued actions
     * @param {ActionsApiGetActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getActions(requestParameters: ActionsApiGetActionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetActionsV1Response>;

    /**
     * 
     * @summary Put action on-hold
     * @param {ActionsApiPutOnHoldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    putOnHold(requestParameters: ActionsApiPutOnHoldRequest, options?: RawAxiosRequestConfig): AxiosPromise<PutOnHoldActionV1Response>;

    /**
     * 
     * @summary Retry action
     * @param {ActionsApiRetryActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    retryAction(requestParameters: ActionsApiRetryActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<RetryActionV1Response>;

}

/**
 * Request parameters for cancelAction operation in ActionsApi.
 * @export
 * @interface ActionsApiCancelActionRequest
 */
export interface ActionsApiCancelActionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiCancelAction
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ActionsApiCancelAction
     */
    readonly changeSetId: string

    /**
     * Action identifier
     * @type {string}
     * @memberof ActionsApiCancelAction
     */
    readonly actionId: string
}

/**
 * Request parameters for getActions operation in ActionsApi.
 * @export
 * @interface ActionsApiGetActionsRequest
 */
export interface ActionsApiGetActionsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiGetActions
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ActionsApiGetActions
     */
    readonly changeSetId: string
}

/**
 * Request parameters for putOnHold operation in ActionsApi.
 * @export
 * @interface ActionsApiPutOnHoldRequest
 */
export interface ActionsApiPutOnHoldRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiPutOnHold
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ActionsApiPutOnHold
     */
    readonly changeSetId: string

    /**
     * Action identifier
     * @type {string}
     * @memberof ActionsApiPutOnHold
     */
    readonly actionId: string
}

/**
 * Request parameters for retryAction operation in ActionsApi.
 * @export
 * @interface ActionsApiRetryActionRequest
 */
export interface ActionsApiRetryActionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ActionsApiRetryAction
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ActionsApiRetryAction
     */
    readonly changeSetId: string

    /**
     * Action identifier
     * @type {string}
     * @memberof ActionsApiRetryAction
     */
    readonly actionId: string
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * 
     * @summary Remove queued action
     * @param {ActionsApiCancelActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public cancelAction(requestParameters: ActionsApiCancelActionRequest, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).cancelAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List queued actions
     * @param {ActionsApiGetActionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getActions(requestParameters: ActionsApiGetActionsRequest, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).getActions(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Put action on-hold
     * @param {ActionsApiPutOnHoldRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public putOnHold(requestParameters: ActionsApiPutOnHoldRequest, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).putOnHold(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retry action
     * @param {ActionsApiRetryActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public retryAction(requestParameters: ActionsApiRetryActionRequest, options?: RawAxiosRequestConfig) {
        return ActionsApiFp(this.configuration).retryAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.actionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChangeSetsApi - axios parameter creator
 * @export
 */
export const ChangeSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a Change Set
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abandonChangeSet: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('abandonChangeSet', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('abandonChangeSet', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a Change Set
         * @param {string} workspaceId Workspace identifier
         * @param {CreateChangeSetV1Request} createChangeSetV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChangeSet: async (workspaceId: string, createChangeSetV1Request: CreateChangeSetV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createChangeSet', 'workspaceId', workspaceId)
            // verify required parameter 'createChangeSetV1Request' is not null or undefined
            assertParamExists('createChangeSet', 'createChangeSetV1Request', createChangeSetV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createChangeSetV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Merge Change Set without approval
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceApply: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('forceApply', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('forceApply', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/force_apply`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Change Set by Change Set Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeSet: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getChangeSet', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getChangeSet', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all active Change Sets
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangeSets: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listChangeSets', 'workspaceId', workspaceId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Change Set post merge status
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStatus: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('mergeStatus', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('mergeStatus', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/merge_status`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Abandon all active Change Sets
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeOpen: async (workspaceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('purgeOpen', 'workspaceId', workspaceId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/purge_open`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Change Set merge approval
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestApproval: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('requestApproval', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('requestApproval', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/request_approval`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChangeSetsApi - functional programming interface
 * @export
 */
export const ChangeSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChangeSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a Change Set
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async abandonChangeSet(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.abandonChangeSet(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.abandonChangeSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a Change Set
         * @param {string} workspaceId Workspace identifier
         * @param {CreateChangeSetV1Request} createChangeSetV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createChangeSet(workspaceId: string, createChangeSetV1Request: CreateChangeSetV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createChangeSet(workspaceId, createChangeSetV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.createChangeSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Merge Change Set without approval
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forceApply(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForceApplyChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forceApply(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.forceApply']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a Change Set by Change Set Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChangeSet(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChangeSet(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.getChangeSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all active Change Sets
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChangeSets(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChangeSets(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.listChangeSets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Change Set post merge status
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeStatus(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MergeStatusV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeStatus(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.mergeStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Abandon all active Change Sets
         * @param {string} workspaceId Workspace identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purgeOpen(workspaceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurgeOpenChangeSetsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purgeOpen(workspaceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.purgeOpen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Change Set merge approval
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestApproval(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RequestApprovalChangeSetV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestApproval(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChangeSetsApi.requestApproval']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChangeSetsApi - factory interface
 * @export
 */
export const ChangeSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChangeSetsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a Change Set
         * @param {ChangeSetsApiAbandonChangeSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        abandonChangeSet(requestParameters: ChangeSetsApiAbandonChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteChangeSetV1Response> {
            return localVarFp.abandonChangeSet(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a Change Set
         * @param {ChangeSetsApiCreateChangeSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChangeSet(requestParameters: ChangeSetsApiCreateChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateChangeSetV1Response> {
            return localVarFp.createChangeSet(requestParameters.workspaceId, requestParameters.createChangeSetV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Merge Change Set without approval
         * @param {ChangeSetsApiForceApplyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forceApply(requestParameters: ChangeSetsApiForceApplyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ForceApplyChangeSetV1Response> {
            return localVarFp.forceApply(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Change Set by Change Set Id
         * @param {ChangeSetsApiGetChangeSetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChangeSet(requestParameters: ChangeSetsApiGetChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetChangeSetV1Response> {
            return localVarFp.getChangeSet(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all active Change Sets
         * @param {ChangeSetsApiListChangeSetsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangeSets(requestParameters: ChangeSetsApiListChangeSetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListChangeSetV1Response> {
            return localVarFp.listChangeSets(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Change Set post merge status
         * @param {ChangeSetsApiMergeStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeStatus(requestParameters: ChangeSetsApiMergeStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<MergeStatusV1Response> {
            return localVarFp.mergeStatus(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Abandon all active Change Sets
         * @param {ChangeSetsApiPurgeOpenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purgeOpen(requestParameters: ChangeSetsApiPurgeOpenRequest, options?: RawAxiosRequestConfig): AxiosPromise<PurgeOpenChangeSetsV1Response> {
            return localVarFp.purgeOpen(requestParameters.workspaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Change Set merge approval
         * @param {ChangeSetsApiRequestApprovalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestApproval(requestParameters: ChangeSetsApiRequestApprovalRequest, options?: RawAxiosRequestConfig): AxiosPromise<RequestApprovalChangeSetV1Response> {
            return localVarFp.requestApproval(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChangeSetsApi - interface
 * @export
 * @interface ChangeSetsApi
 */
export interface ChangeSetsApiInterface {
    /**
     * 
     * @summary Delete a Change Set
     * @param {ChangeSetsApiAbandonChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    abandonChangeSet(requestParameters: ChangeSetsApiAbandonChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteChangeSetV1Response>;

    /**
     * 
     * @summary Create a Change Set
     * @param {ChangeSetsApiCreateChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    createChangeSet(requestParameters: ChangeSetsApiCreateChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateChangeSetV1Response>;

    /**
     * 
     * @summary Merge Change Set without approval
     * @param {ChangeSetsApiForceApplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    forceApply(requestParameters: ChangeSetsApiForceApplyRequest, options?: RawAxiosRequestConfig): AxiosPromise<ForceApplyChangeSetV1Response>;

    /**
     * 
     * @summary Get a Change Set by Change Set Id
     * @param {ChangeSetsApiGetChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    getChangeSet(requestParameters: ChangeSetsApiGetChangeSetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetChangeSetV1Response>;

    /**
     * 
     * @summary List all active Change Sets
     * @param {ChangeSetsApiListChangeSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    listChangeSets(requestParameters: ChangeSetsApiListChangeSetsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListChangeSetV1Response>;

    /**
     * 
     * @summary Get Change Set post merge status
     * @param {ChangeSetsApiMergeStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    mergeStatus(requestParameters: ChangeSetsApiMergeStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<MergeStatusV1Response>;

    /**
     * 
     * @summary Abandon all active Change Sets
     * @param {ChangeSetsApiPurgeOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    purgeOpen(requestParameters: ChangeSetsApiPurgeOpenRequest, options?: RawAxiosRequestConfig): AxiosPromise<PurgeOpenChangeSetsV1Response>;

    /**
     * 
     * @summary Request Change Set merge approval
     * @param {ChangeSetsApiRequestApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApiInterface
     */
    requestApproval(requestParameters: ChangeSetsApiRequestApprovalRequest, options?: RawAxiosRequestConfig): AxiosPromise<RequestApprovalChangeSetV1Response>;

}

/**
 * Request parameters for abandonChangeSet operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiAbandonChangeSetRequest
 */
export interface ChangeSetsApiAbandonChangeSetRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiAbandonChangeSet
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ChangeSetsApiAbandonChangeSet
     */
    readonly changeSetId: string
}

/**
 * Request parameters for createChangeSet operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiCreateChangeSetRequest
 */
export interface ChangeSetsApiCreateChangeSetRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiCreateChangeSet
     */
    readonly workspaceId: string

    /**
     * 
     * @type {CreateChangeSetV1Request}
     * @memberof ChangeSetsApiCreateChangeSet
     */
    readonly createChangeSetV1Request: CreateChangeSetV1Request
}

/**
 * Request parameters for forceApply operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiForceApplyRequest
 */
export interface ChangeSetsApiForceApplyRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiForceApply
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ChangeSetsApiForceApply
     */
    readonly changeSetId: string
}

/**
 * Request parameters for getChangeSet operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiGetChangeSetRequest
 */
export interface ChangeSetsApiGetChangeSetRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiGetChangeSet
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ChangeSetsApiGetChangeSet
     */
    readonly changeSetId: string
}

/**
 * Request parameters for listChangeSets operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiListChangeSetsRequest
 */
export interface ChangeSetsApiListChangeSetsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiListChangeSets
     */
    readonly workspaceId: string
}

/**
 * Request parameters for mergeStatus operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiMergeStatusRequest
 */
export interface ChangeSetsApiMergeStatusRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiMergeStatus
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ChangeSetsApiMergeStatus
     */
    readonly changeSetId: string
}

/**
 * Request parameters for purgeOpen operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiPurgeOpenRequest
 */
export interface ChangeSetsApiPurgeOpenRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiPurgeOpen
     */
    readonly workspaceId: string
}

/**
 * Request parameters for requestApproval operation in ChangeSetsApi.
 * @export
 * @interface ChangeSetsApiRequestApprovalRequest
 */
export interface ChangeSetsApiRequestApprovalRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ChangeSetsApiRequestApproval
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ChangeSetsApiRequestApproval
     */
    readonly changeSetId: string
}

/**
 * ChangeSetsApi - object-oriented interface
 * @export
 * @class ChangeSetsApi
 * @extends {BaseAPI}
 */
export class ChangeSetsApi extends BaseAPI implements ChangeSetsApiInterface {
    /**
     * 
     * @summary Delete a Change Set
     * @param {ChangeSetsApiAbandonChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public abandonChangeSet(requestParameters: ChangeSetsApiAbandonChangeSetRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).abandonChangeSet(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a Change Set
     * @param {ChangeSetsApiCreateChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public createChangeSet(requestParameters: ChangeSetsApiCreateChangeSetRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).createChangeSet(requestParameters.workspaceId, requestParameters.createChangeSetV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Merge Change Set without approval
     * @param {ChangeSetsApiForceApplyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public forceApply(requestParameters: ChangeSetsApiForceApplyRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).forceApply(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Change Set by Change Set Id
     * @param {ChangeSetsApiGetChangeSetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public getChangeSet(requestParameters: ChangeSetsApiGetChangeSetRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).getChangeSet(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all active Change Sets
     * @param {ChangeSetsApiListChangeSetsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public listChangeSets(requestParameters: ChangeSetsApiListChangeSetsRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).listChangeSets(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Change Set post merge status
     * @param {ChangeSetsApiMergeStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public mergeStatus(requestParameters: ChangeSetsApiMergeStatusRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).mergeStatus(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Abandon all active Change Sets
     * @param {ChangeSetsApiPurgeOpenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public purgeOpen(requestParameters: ChangeSetsApiPurgeOpenRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).purgeOpen(requestParameters.workspaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Change Set merge approval
     * @param {ChangeSetsApiRequestApprovalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeSetsApi
     */
    public requestApproval(requestParameters: ChangeSetsApiRequestApprovalRequest, options?: RawAxiosRequestConfig) {
        return ChangeSetsApiFp(this.configuration).requestApproval(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ComponentsApi - axios parameter creator
 * @export
 */
export const ComponentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Queue action for a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {AddActionV1Request} addActionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAction: async (workspaceId: string, changeSetId: string, componentId: string, addActionV1Request: AddActionV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('addAction', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('addAction', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('addAction', 'componentId', componentId)
            // verify required parameter 'addActionV1Request' is not null or undefined
            assertParamExists('addAction', 'addActionV1Request', addActionV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/action`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addActionV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateComponentV1Request} createComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComponent: async (workspaceId: string, changeSetId: string, createComponentV1Request: CreateComponentV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createComponent', 'changeSetId', changeSetId)
            // verify required parameter 'createComponentV1Request' is not null or undefined
            assertParamExists('createComponent', 'createComponentV1Request', createComponentV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createComponentV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComponent: async (workspaceId: string, changeSetId: string, componentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('deleteComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('deleteComponent', 'componentId', componentId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Duplicate a list of components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {DuplicateComponentsV1Request} duplicateComponentsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateComponents: async (workspaceId: string, changeSetId: string, duplicateComponentsV1Request: DuplicateComponentsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('duplicateComponents', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('duplicateComponents', 'changeSetId', changeSetId)
            // verify required parameter 'duplicateComponentsV1Request' is not null or undefined
            assertParamExists('duplicateComponents', 'duplicateComponentsV1Request', duplicateComponentsV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/duplicate`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(duplicateComponentsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Erase a component without queuing a delete action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseComponent: async (workspaceId: string, changeSetId: string, componentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('eraseComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('eraseComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('eraseComponent', 'componentId', componentId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/erase`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Execute a component\'s management function
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {ExecuteManagementFunctionV1Request} executeManagementFunctionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeManagementFunction: async (workspaceId: string, changeSetId: string, componentId: string, executeManagementFunctionV1Request: ExecuteManagementFunctionV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('executeManagementFunction', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('executeManagementFunction', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('executeManagementFunction', 'componentId', componentId)
            // verify required parameter 'executeManagementFunctionV1Request' is not null or undefined
            assertParamExists('executeManagementFunction', 'executeManagementFunctionV1Request', executeManagementFunctionV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/execute-management-function`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(executeManagementFunctionV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find a component by name or component Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string | null} [component] 
         * @param {string | null} [componentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findComponent: async (workspaceId: string, changeSetId: string, component?: string | null, componentId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('findComponent', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/find`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (component !== undefined) {
                localVarQueryParameter['component'] = component;
            }

            if (componentId !== undefined) {
                localVarQueryParameter['componentId'] = componentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate a template
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {GenerateTemplateV1Request} generateTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTemplate: async (workspaceId: string, changeSetId: string, generateTemplateV1Request: GenerateTemplateV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('generateTemplate', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('generateTemplate', 'changeSetId', changeSetId)
            // verify required parameter 'generateTemplateV1Request' is not null or undefined
            assertParamExists('generateTemplate', 'generateTemplateV1Request', generateTemplateV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/generate_template`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateTemplateV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a component by component Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponent: async (workspaceId: string, changeSetId: string, componentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('getComponent', 'componentId', componentId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} [limit] Maximum number of results to return (default: 50, max: 300)
         * @param {string} [cursor] Cursor for pagination (ComponentId of the last item from previous page)
         * @param {boolean} [includeCodegen] Allow returning the codegen for the cloudformation template for the component (if it exists)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listComponents: async (workspaceId: string, changeSetId: string, limit?: string, cursor?: string, includeCodegen?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listComponents', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('listComponents', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (includeCodegen !== undefined) {
                localVarQueryParameter['includeCodegen'] = includeCodegen;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Putting a component under the management of another component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {ManageComponentV1Request} manageComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageComponent: async (workspaceId: string, changeSetId: string, componentId: string, manageComponentV1Request: ManageComponentV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('manageComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('manageComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('manageComponent', 'componentId', componentId)
            // verify required parameter 'manageComponentV1Request' is not null or undefined
            assertParamExists('manageComponent', 'manageComponentV1Request', manageComponentV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/manage`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(manageComponentV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Restore a component that is marked for deletion
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreComponent: async (workspaceId: string, changeSetId: string, componentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('restoreComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('restoreComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('restoreComponent', 'componentId', componentId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/restore`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complex search for components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {SearchComponentsV1Request} searchComponentsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchComponents: async (workspaceId: string, changeSetId: string, searchComponentsV1Request: SearchComponentsV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchComponents', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('searchComponents', 'changeSetId', changeSetId)
            // verify required parameter 'searchComponentsV1Request' is not null or undefined
            assertParamExists('searchComponents', 'searchComponentsV1Request', searchComponentsV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/search`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchComponentsV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {UpdateComponentV1Request} updateComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComponent: async (workspaceId: string, changeSetId: string, componentId: string, updateComponentV1Request: UpdateComponentV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('updateComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('updateComponent', 'componentId', componentId)
            // verify required parameter 'updateComponentV1Request' is not null or undefined
            assertParamExists('updateComponent', 'updateComponentV1Request', updateComponentV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateComponentV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upgrade a component to the latest schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeComponent: async (workspaceId: string, changeSetId: string, componentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('upgradeComponent', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('upgradeComponent', 'changeSetId', changeSetId)
            // verify required parameter 'componentId' is not null or undefined
            assertParamExists('upgradeComponent', 'componentId', componentId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/components/{component_id}/upgrade`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"component_id"}}`, encodeURIComponent(String(componentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComponentsApi - functional programming interface
 * @export
 */
export const ComponentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComponentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Queue action for a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {AddActionV1Request} addActionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addAction(workspaceId: string, changeSetId: string, componentId: string, addActionV1Request: AddActionV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddActionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addAction(workspaceId, changeSetId, componentId, addActionV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.addAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateComponentV1Request} createComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createComponent(workspaceId: string, changeSetId: string, createComponentV1Request: CreateComponentV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createComponent(workspaceId, changeSetId, createComponentV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.createComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteComponent(workspaceId: string, changeSetId: string, componentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteComponent(workspaceId, changeSetId, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.deleteComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Duplicate a list of components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {DuplicateComponentsV1Request} duplicateComponentsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async duplicateComponents(workspaceId: string, changeSetId: string, duplicateComponentsV1Request: DuplicateComponentsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DuplicateComponentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.duplicateComponents(workspaceId, changeSetId, duplicateComponentsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.duplicateComponents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Erase a component without queuing a delete action
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eraseComponent(workspaceId: string, changeSetId: string, componentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EraseComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eraseComponent(workspaceId, changeSetId, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.eraseComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Execute a component\'s management function
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {ExecuteManagementFunctionV1Request} executeManagementFunctionV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeManagementFunction(workspaceId: string, changeSetId: string, componentId: string, executeManagementFunctionV1Request: ExecuteManagementFunctionV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExecuteManagementFunctionV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeManagementFunction(workspaceId, changeSetId, componentId, executeManagementFunctionV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.executeManagementFunction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find a component by name or component Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string | null} [component] 
         * @param {string | null} [componentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findComponent(workspaceId: string, changeSetId: string, component?: string | null, componentId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findComponent(workspaceId, changeSetId, component, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.findComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate a template
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {GenerateTemplateV1Request} generateTemplateV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTemplate(workspaceId: string, changeSetId: string, generateTemplateV1Request: GenerateTemplateV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateTemplateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTemplate(workspaceId, changeSetId, generateTemplateV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.generateTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a component by component Id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComponent(workspaceId: string, changeSetId: string, componentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComponent(workspaceId, changeSetId, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.getComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} [limit] Maximum number of results to return (default: 50, max: 300)
         * @param {string} [cursor] Cursor for pagination (ComponentId of the last item from previous page)
         * @param {boolean} [includeCodegen] Allow returning the codegen for the cloudformation template for the component (if it exists)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listComponents(workspaceId: string, changeSetId: string, limit?: string, cursor?: string, includeCodegen?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListComponentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listComponents(workspaceId, changeSetId, limit, cursor, includeCodegen, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.listComponents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Putting a component under the management of another component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {ManageComponentV1Request} manageComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async manageComponent(workspaceId: string, changeSetId: string, componentId: string, manageComponentV1Request: ManageComponentV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManageComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.manageComponent(workspaceId, changeSetId, componentId, manageComponentV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.manageComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Restore a component that is marked for deletion
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreComponent(workspaceId: string, changeSetId: string, componentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreComponent(workspaceId, changeSetId, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.restoreComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Complex search for components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {SearchComponentsV1Request} searchComponentsV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchComponents(workspaceId: string, changeSetId: string, searchComponentsV1Request: SearchComponentsV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchComponentsV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchComponents(workspaceId, changeSetId, searchComponentsV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.searchComponents']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a component
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {UpdateComponentV1Request} updateComponentV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateComponent(workspaceId: string, changeSetId: string, componentId: string, updateComponentV1Request: UpdateComponentV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateComponent(workspaceId, changeSetId, componentId, updateComponentV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.updateComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upgrade a component to the latest schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} componentId Component identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upgradeComponent(workspaceId: string, changeSetId: string, componentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpgradeComponentV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upgradeComponent(workspaceId, changeSetId, componentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ComponentsApi.upgradeComponent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ComponentsApi - factory interface
 * @export
 */
export const ComponentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComponentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Queue action for a component
         * @param {ComponentsApiAddActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAction(requestParameters: ComponentsApiAddActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddActionV1Response> {
            return localVarFp.addAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.addActionV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a component
         * @param {ComponentsApiCreateComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComponent(requestParameters: ComponentsApiCreateComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateComponentV1Response> {
            return localVarFp.createComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createComponentV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a component
         * @param {ComponentsApiDeleteComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteComponent(requestParameters: ComponentsApiDeleteComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteComponentV1Response> {
            return localVarFp.deleteComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Duplicate a list of components
         * @param {ComponentsApiDuplicateComponentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateComponents(requestParameters: ComponentsApiDuplicateComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DuplicateComponentsV1Response> {
            return localVarFp.duplicateComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.duplicateComponentsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Erase a component without queuing a delete action
         * @param {ComponentsApiEraseComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eraseComponent(requestParameters: ComponentsApiEraseComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EraseComponentV1Response> {
            return localVarFp.eraseComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Execute a component\'s management function
         * @param {ComponentsApiExecuteManagementFunctionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeManagementFunction(requestParameters: ComponentsApiExecuteManagementFunctionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteManagementFunctionV1Response> {
            return localVarFp.executeManagementFunction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.executeManagementFunctionV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find a component by name or component Id
         * @param {ComponentsApiFindComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findComponent(requestParameters: ComponentsApiFindComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetComponentV1Response> {
            return localVarFp.findComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.component, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate a template
         * @param {ComponentsApiGenerateTemplateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTemplate(requestParameters: ComponentsApiGenerateTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateTemplateV1Response> {
            return localVarFp.generateTemplate(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.generateTemplateV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a component by component Id
         * @param {ComponentsApiGetComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComponent(requestParameters: ComponentsApiGetComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetComponentV1Response> {
            return localVarFp.getComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all components
         * @param {ComponentsApiListComponentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listComponents(requestParameters: ComponentsApiListComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListComponentsV1Response> {
            return localVarFp.listComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.limit, requestParameters.cursor, requestParameters.includeCodegen, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Putting a component under the management of another component
         * @param {ComponentsApiManageComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        manageComponent(requestParameters: ComponentsApiManageComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<ManageComponentV1Response> {
            return localVarFp.manageComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.manageComponentV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Restore a component that is marked for deletion
         * @param {ComponentsApiRestoreComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreComponent(requestParameters: ComponentsApiRestoreComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestoreComponentV1Response> {
            return localVarFp.restoreComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complex search for components
         * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchComponents(requestParameters: ComponentsApiSearchComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchComponentsV1Response> {
            return localVarFp.searchComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.searchComponentsV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a component
         * @param {ComponentsApiUpdateComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateComponent(requestParameters: ComponentsApiUpdateComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateComponentV1Response> {
            return localVarFp.updateComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.updateComponentV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upgrade a component to the latest schema variant
         * @param {ComponentsApiUpgradeComponentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upgradeComponent(requestParameters: ComponentsApiUpgradeComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpgradeComponentV1Response> {
            return localVarFp.upgradeComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComponentsApi - interface
 * @export
 * @interface ComponentsApi
 */
export interface ComponentsApiInterface {
    /**
     * 
     * @summary Queue action for a component
     * @param {ComponentsApiAddActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    addAction(requestParameters: ComponentsApiAddActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<AddActionV1Response>;

    /**
     * 
     * @summary Create a component
     * @param {ComponentsApiCreateComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    createComponent(requestParameters: ComponentsApiCreateComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateComponentV1Response>;

    /**
     * 
     * @summary Delete a component
     * @param {ComponentsApiDeleteComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    deleteComponent(requestParameters: ComponentsApiDeleteComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteComponentV1Response>;

    /**
     * 
     * @summary Duplicate a list of components
     * @param {ComponentsApiDuplicateComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    duplicateComponents(requestParameters: ComponentsApiDuplicateComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DuplicateComponentsV1Response>;

    /**
     * 
     * @summary Erase a component without queuing a delete action
     * @param {ComponentsApiEraseComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    eraseComponent(requestParameters: ComponentsApiEraseComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<EraseComponentV1Response>;

    /**
     * 
     * @summary Execute a component\'s management function
     * @param {ComponentsApiExecuteManagementFunctionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    executeManagementFunction(requestParameters: ComponentsApiExecuteManagementFunctionRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExecuteManagementFunctionV1Response>;

    /**
     * 
     * @summary Find a component by name or component Id
     * @param {ComponentsApiFindComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    findComponent(requestParameters: ComponentsApiFindComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetComponentV1Response>;

    /**
     * 
     * @summary Generate a template
     * @param {ComponentsApiGenerateTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    generateTemplate(requestParameters: ComponentsApiGenerateTemplateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateTemplateV1Response>;

    /**
     * 
     * @summary Get a component by component Id
     * @param {ComponentsApiGetComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    getComponent(requestParameters: ComponentsApiGetComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetComponentV1Response>;

    /**
     * 
     * @summary List all components
     * @param {ComponentsApiListComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    listComponents(requestParameters: ComponentsApiListComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListComponentsV1Response>;

    /**
     * 
     * @summary Putting a component under the management of another component
     * @param {ComponentsApiManageComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    manageComponent(requestParameters: ComponentsApiManageComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<ManageComponentV1Response>;

    /**
     * 
     * @summary Restore a component that is marked for deletion
     * @param {ComponentsApiRestoreComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    restoreComponent(requestParameters: ComponentsApiRestoreComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestoreComponentV1Response>;

    /**
     * 
     * @summary Complex search for components
     * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    searchComponents(requestParameters: ComponentsApiSearchComponentsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchComponentsV1Response>;

    /**
     * 
     * @summary Update a component
     * @param {ComponentsApiUpdateComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    updateComponent(requestParameters: ComponentsApiUpdateComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateComponentV1Response>;

    /**
     * 
     * @summary Upgrade a component to the latest schema variant
     * @param {ComponentsApiUpgradeComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApiInterface
     */
    upgradeComponent(requestParameters: ComponentsApiUpgradeComponentRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpgradeComponentV1Response>;

}

/**
 * Request parameters for addAction operation in ComponentsApi.
 * @export
 * @interface ComponentsApiAddActionRequest
 */
export interface ComponentsApiAddActionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiAddAction
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiAddAction
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiAddAction
     */
    readonly componentId: string

    /**
     * 
     * @type {AddActionV1Request}
     * @memberof ComponentsApiAddAction
     */
    readonly addActionV1Request: AddActionV1Request
}

/**
 * Request parameters for createComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiCreateComponentRequest
 */
export interface ComponentsApiCreateComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiCreateComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiCreateComponent
     */
    readonly changeSetId: string

    /**
     * 
     * @type {CreateComponentV1Request}
     * @memberof ComponentsApiCreateComponent
     */
    readonly createComponentV1Request: CreateComponentV1Request
}

/**
 * Request parameters for deleteComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiDeleteComponentRequest
 */
export interface ComponentsApiDeleteComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiDeleteComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiDeleteComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiDeleteComponent
     */
    readonly componentId: string
}

/**
 * Request parameters for duplicateComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiDuplicateComponentsRequest
 */
export interface ComponentsApiDuplicateComponentsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiDuplicateComponents
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiDuplicateComponents
     */
    readonly changeSetId: string

    /**
     * 
     * @type {DuplicateComponentsV1Request}
     * @memberof ComponentsApiDuplicateComponents
     */
    readonly duplicateComponentsV1Request: DuplicateComponentsV1Request
}

/**
 * Request parameters for eraseComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiEraseComponentRequest
 */
export interface ComponentsApiEraseComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiEraseComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiEraseComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiEraseComponent
     */
    readonly componentId: string
}

/**
 * Request parameters for executeManagementFunction operation in ComponentsApi.
 * @export
 * @interface ComponentsApiExecuteManagementFunctionRequest
 */
export interface ComponentsApiExecuteManagementFunctionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiExecuteManagementFunction
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiExecuteManagementFunction
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiExecuteManagementFunction
     */
    readonly componentId: string

    /**
     * 
     * @type {ExecuteManagementFunctionV1Request}
     * @memberof ComponentsApiExecuteManagementFunction
     */
    readonly executeManagementFunctionV1Request: ExecuteManagementFunctionV1Request
}

/**
 * Request parameters for findComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiFindComponentRequest
 */
export interface ComponentsApiFindComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiFindComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiFindComponent
     */
    readonly changeSetId: string

    /**
     * 
     * @type {string}
     * @memberof ComponentsApiFindComponent
     */
    readonly component?: string | null

    /**
     * 
     * @type {string}
     * @memberof ComponentsApiFindComponent
     */
    readonly componentId?: string | null
}

/**
 * Request parameters for generateTemplate operation in ComponentsApi.
 * @export
 * @interface ComponentsApiGenerateTemplateRequest
 */
export interface ComponentsApiGenerateTemplateRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiGenerateTemplate
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiGenerateTemplate
     */
    readonly changeSetId: string

    /**
     * 
     * @type {GenerateTemplateV1Request}
     * @memberof ComponentsApiGenerateTemplate
     */
    readonly generateTemplateV1Request: GenerateTemplateV1Request
}

/**
 * Request parameters for getComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiGetComponentRequest
 */
export interface ComponentsApiGetComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiGetComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiGetComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiGetComponent
     */
    readonly componentId: string
}

/**
 * Request parameters for listComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiListComponentsRequest
 */
export interface ComponentsApiListComponentsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiListComponents
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiListComponents
     */
    readonly changeSetId: string

    /**
     * Maximum number of results to return (default: 50, max: 300)
     * @type {string}
     * @memberof ComponentsApiListComponents
     */
    readonly limit?: string

    /**
     * Cursor for pagination (ComponentId of the last item from previous page)
     * @type {string}
     * @memberof ComponentsApiListComponents
     */
    readonly cursor?: string

    /**
     * Allow returning the codegen for the cloudformation template for the component (if it exists)
     * @type {boolean}
     * @memberof ComponentsApiListComponents
     */
    readonly includeCodegen?: boolean
}

/**
 * Request parameters for manageComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiManageComponentRequest
 */
export interface ComponentsApiManageComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiManageComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiManageComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiManageComponent
     */
    readonly componentId: string

    /**
     * 
     * @type {ManageComponentV1Request}
     * @memberof ComponentsApiManageComponent
     */
    readonly manageComponentV1Request: ManageComponentV1Request
}

/**
 * Request parameters for restoreComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiRestoreComponentRequest
 */
export interface ComponentsApiRestoreComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiRestoreComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiRestoreComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiRestoreComponent
     */
    readonly componentId: string
}

/**
 * Request parameters for searchComponents operation in ComponentsApi.
 * @export
 * @interface ComponentsApiSearchComponentsRequest
 */
export interface ComponentsApiSearchComponentsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiSearchComponents
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiSearchComponents
     */
    readonly changeSetId: string

    /**
     * 
     * @type {SearchComponentsV1Request}
     * @memberof ComponentsApiSearchComponents
     */
    readonly searchComponentsV1Request: SearchComponentsV1Request
}

/**
 * Request parameters for updateComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiUpdateComponentRequest
 */
export interface ComponentsApiUpdateComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiUpdateComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiUpdateComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiUpdateComponent
     */
    readonly componentId: string

    /**
     * 
     * @type {UpdateComponentV1Request}
     * @memberof ComponentsApiUpdateComponent
     */
    readonly updateComponentV1Request: UpdateComponentV1Request
}

/**
 * Request parameters for upgradeComponent operation in ComponentsApi.
 * @export
 * @interface ComponentsApiUpgradeComponentRequest
 */
export interface ComponentsApiUpgradeComponentRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ComponentsApiUpgradeComponent
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ComponentsApiUpgradeComponent
     */
    readonly changeSetId: string

    /**
     * Component identifier
     * @type {string}
     * @memberof ComponentsApiUpgradeComponent
     */
    readonly componentId: string
}

/**
 * ComponentsApi - object-oriented interface
 * @export
 * @class ComponentsApi
 * @extends {BaseAPI}
 */
export class ComponentsApi extends BaseAPI implements ComponentsApiInterface {
    /**
     * 
     * @summary Queue action for a component
     * @param {ComponentsApiAddActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public addAction(requestParameters: ComponentsApiAddActionRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).addAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.addActionV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a component
     * @param {ComponentsApiCreateComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public createComponent(requestParameters: ComponentsApiCreateComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).createComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createComponentV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a component
     * @param {ComponentsApiDeleteComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public deleteComponent(requestParameters: ComponentsApiDeleteComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).deleteComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Duplicate a list of components
     * @param {ComponentsApiDuplicateComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public duplicateComponents(requestParameters: ComponentsApiDuplicateComponentsRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).duplicateComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.duplicateComponentsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Erase a component without queuing a delete action
     * @param {ComponentsApiEraseComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public eraseComponent(requestParameters: ComponentsApiEraseComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).eraseComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Execute a component\'s management function
     * @param {ComponentsApiExecuteManagementFunctionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public executeManagementFunction(requestParameters: ComponentsApiExecuteManagementFunctionRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).executeManagementFunction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.executeManagementFunctionV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find a component by name or component Id
     * @param {ComponentsApiFindComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public findComponent(requestParameters: ComponentsApiFindComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).findComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.component, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate a template
     * @param {ComponentsApiGenerateTemplateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public generateTemplate(requestParameters: ComponentsApiGenerateTemplateRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).generateTemplate(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.generateTemplateV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a component by component Id
     * @param {ComponentsApiGetComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public getComponent(requestParameters: ComponentsApiGetComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).getComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all components
     * @param {ComponentsApiListComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public listComponents(requestParameters: ComponentsApiListComponentsRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).listComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.limit, requestParameters.cursor, requestParameters.includeCodegen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Putting a component under the management of another component
     * @param {ComponentsApiManageComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public manageComponent(requestParameters: ComponentsApiManageComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).manageComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.manageComponentV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Restore a component that is marked for deletion
     * @param {ComponentsApiRestoreComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public restoreComponent(requestParameters: ComponentsApiRestoreComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).restoreComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complex search for components
     * @param {ComponentsApiSearchComponentsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public searchComponents(requestParameters: ComponentsApiSearchComponentsRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).searchComponents(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.searchComponentsV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a component
     * @param {ComponentsApiUpdateComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public updateComponent(requestParameters: ComponentsApiUpdateComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).updateComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, requestParameters.updateComponentV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upgrade a component to the latest schema variant
     * @param {ComponentsApiUpgradeComponentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComponentsApi
     */
    public upgradeComponent(requestParameters: ComponentsApiUpgradeComponentRequest, options?: RawAxiosRequestConfig) {
        return ComponentsApiFp(this.configuration).upgradeComponent(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.componentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FuncsApi - axios parameter creator
 * @export
 */
export const FuncsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get function details
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunc: async (workspaceId: string, changeSetId: string, funcId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFunc', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getFunc', 'changeSetId', changeSetId)
            // verify required parameter 'funcId' is not null or undefined
            assertParamExists('getFunc', 'funcId', funcId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/funcs/{func_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"func_id"}}`, encodeURIComponent(String(funcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get func execution run logs
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcRunId Func run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuncRun: async (workspaceId: string, changeSetId: string, funcRunId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getFuncRun', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getFuncRun', 'changeSetId', changeSetId)
            // verify required parameter 'funcRunId' is not null or undefined
            assertParamExists('getFuncRun', 'funcRunId', funcRunId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/funcs/runs/{func_run_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"func_run_id"}}`, encodeURIComponent(String(funcRunId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlocks a func - if there\'s already an unlocked function, then we return that
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {UnlockFuncV1Request} unlockFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockFunc: async (workspaceId: string, changeSetId: string, funcId: string, unlockFuncV1Request: UnlockFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlockFunc', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('unlockFunc', 'changeSetId', changeSetId)
            // verify required parameter 'funcId' is not null or undefined
            assertParamExists('unlockFunc', 'funcId', funcId)
            // verify required parameter 'unlockFuncV1Request' is not null or undefined
            assertParamExists('unlockFunc', 'unlockFuncV1Request', unlockFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/funcs/{func_id}/unlock`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"func_id"}}`, encodeURIComponent(String(funcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unlockFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a func
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {UpdateFuncV1Request} updateFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunc: async (workspaceId: string, changeSetId: string, funcId: string, updateFuncV1Request: UpdateFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateFunc', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('updateFunc', 'changeSetId', changeSetId)
            // verify required parameter 'funcId' is not null or undefined
            assertParamExists('updateFunc', 'funcId', funcId)
            // verify required parameter 'updateFuncV1Request' is not null or undefined
            assertParamExists('updateFunc', 'updateFuncV1Request', updateFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/funcs/{func_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"func_id"}}`, encodeURIComponent(String(funcId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FuncsApi - functional programming interface
 * @export
 */
export const FuncsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FuncsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get function details
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunc(workspaceId: string, changeSetId: string, funcId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunc(workspaceId, changeSetId, funcId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuncsApi.getFunc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get func execution run logs
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcRunId Func run identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFuncRun(workspaceId: string, changeSetId: string, funcRunId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFuncRunV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFuncRun(workspaceId, changeSetId, funcRunId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuncsApi.getFuncRun']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unlocks a func - if there\'s already an unlocked function, then we return that
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {UnlockFuncV1Request} unlockFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockFunc(workspaceId: string, changeSetId: string, funcId: string, unlockFuncV1Request: UnlockFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnlockFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockFunc(workspaceId, changeSetId, funcId, unlockFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuncsApi.unlockFunc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a func
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} funcId Func identifier
         * @param {UpdateFuncV1Request} updateFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFunc(workspaceId: string, changeSetId: string, funcId: string, updateFuncV1Request: UpdateFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunc(workspaceId, changeSetId, funcId, updateFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FuncsApi.updateFunc']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FuncsApi - factory interface
 * @export
 */
export const FuncsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FuncsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get function details
         * @param {FuncsApiGetFuncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunc(requestParameters: FuncsApiGetFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFuncV1Response> {
            return localVarFp.getFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get func execution run logs
         * @param {FuncsApiGetFuncRunRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFuncRun(requestParameters: FuncsApiGetFuncRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFuncRunV1Response> {
            return localVarFp.getFuncRun(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcRunId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlocks a func - if there\'s already an unlocked function, then we return that
         * @param {FuncsApiUnlockFuncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockFunc(requestParameters: FuncsApiUnlockFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnlockFuncV1Response> {
            return localVarFp.unlockFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, requestParameters.unlockFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a func
         * @param {FuncsApiUpdateFuncRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunc(requestParameters: FuncsApiUpdateFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateFuncV1Response> {
            return localVarFp.updateFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, requestParameters.updateFuncV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FuncsApi - interface
 * @export
 * @interface FuncsApi
 */
export interface FuncsApiInterface {
    /**
     * 
     * @summary Get function details
     * @param {FuncsApiGetFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApiInterface
     */
    getFunc(requestParameters: FuncsApiGetFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFuncV1Response>;

    /**
     * 
     * @summary Get func execution run logs
     * @param {FuncsApiGetFuncRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApiInterface
     */
    getFuncRun(requestParameters: FuncsApiGetFuncRunRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetFuncRunV1Response>;

    /**
     * 
     * @summary Unlocks a func - if there\'s already an unlocked function, then we return that
     * @param {FuncsApiUnlockFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApiInterface
     */
    unlockFunc(requestParameters: FuncsApiUnlockFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnlockFuncV1Response>;

    /**
     * 
     * @summary Update a func
     * @param {FuncsApiUpdateFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApiInterface
     */
    updateFunc(requestParameters: FuncsApiUpdateFuncRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateFuncV1Response>;

}

/**
 * Request parameters for getFunc operation in FuncsApi.
 * @export
 * @interface FuncsApiGetFuncRequest
 */
export interface FuncsApiGetFuncRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof FuncsApiGetFunc
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof FuncsApiGetFunc
     */
    readonly changeSetId: string

    /**
     * Func identifier
     * @type {string}
     * @memberof FuncsApiGetFunc
     */
    readonly funcId: string
}

/**
 * Request parameters for getFuncRun operation in FuncsApi.
 * @export
 * @interface FuncsApiGetFuncRunRequest
 */
export interface FuncsApiGetFuncRunRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof FuncsApiGetFuncRun
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof FuncsApiGetFuncRun
     */
    readonly changeSetId: string

    /**
     * Func run identifier
     * @type {string}
     * @memberof FuncsApiGetFuncRun
     */
    readonly funcRunId: string
}

/**
 * Request parameters for unlockFunc operation in FuncsApi.
 * @export
 * @interface FuncsApiUnlockFuncRequest
 */
export interface FuncsApiUnlockFuncRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof FuncsApiUnlockFunc
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof FuncsApiUnlockFunc
     */
    readonly changeSetId: string

    /**
     * Func identifier
     * @type {string}
     * @memberof FuncsApiUnlockFunc
     */
    readonly funcId: string

    /**
     * 
     * @type {UnlockFuncV1Request}
     * @memberof FuncsApiUnlockFunc
     */
    readonly unlockFuncV1Request: UnlockFuncV1Request
}

/**
 * Request parameters for updateFunc operation in FuncsApi.
 * @export
 * @interface FuncsApiUpdateFuncRequest
 */
export interface FuncsApiUpdateFuncRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof FuncsApiUpdateFunc
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof FuncsApiUpdateFunc
     */
    readonly changeSetId: string

    /**
     * Func identifier
     * @type {string}
     * @memberof FuncsApiUpdateFunc
     */
    readonly funcId: string

    /**
     * 
     * @type {UpdateFuncV1Request}
     * @memberof FuncsApiUpdateFunc
     */
    readonly updateFuncV1Request: UpdateFuncV1Request
}

/**
 * FuncsApi - object-oriented interface
 * @export
 * @class FuncsApi
 * @extends {BaseAPI}
 */
export class FuncsApi extends BaseAPI implements FuncsApiInterface {
    /**
     * 
     * @summary Get function details
     * @param {FuncsApiGetFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApi
     */
    public getFunc(requestParameters: FuncsApiGetFuncRequest, options?: RawAxiosRequestConfig) {
        return FuncsApiFp(this.configuration).getFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get func execution run logs
     * @param {FuncsApiGetFuncRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApi
     */
    public getFuncRun(requestParameters: FuncsApiGetFuncRunRequest, options?: RawAxiosRequestConfig) {
        return FuncsApiFp(this.configuration).getFuncRun(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcRunId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlocks a func - if there\'s already an unlocked function, then we return that
     * @param {FuncsApiUnlockFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApi
     */
    public unlockFunc(requestParameters: FuncsApiUnlockFuncRequest, options?: RawAxiosRequestConfig) {
        return FuncsApiFp(this.configuration).unlockFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, requestParameters.unlockFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a func
     * @param {FuncsApiUpdateFuncRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FuncsApi
     */
    public updateFunc(requestParameters: FuncsApiUpdateFuncRequest, options?: RawAxiosRequestConfig) {
        return FuncsApiFp(this.configuration).updateFunc(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.funcId, requestParameters.updateFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ManagementFuncsApi - axios parameter creator
 * @export
 */
export const ManagementFuncsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get management funcs job state details
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} managementFuncJobStateId Management Func Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagementFuncRunState: async (workspaceId: string, changeSetId: string, managementFuncJobStateId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getManagementFuncRunState', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getManagementFuncRunState', 'changeSetId', changeSetId)
            // verify required parameter 'managementFuncJobStateId' is not null or undefined
            assertParamExists('getManagementFuncRunState', 'managementFuncJobStateId', managementFuncJobStateId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/management-funcs/{management_func_job_state_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"management_func_job_state_id"}}`, encodeURIComponent(String(managementFuncJobStateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagementFuncsApi - functional programming interface
 * @export
 */
export const ManagementFuncsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagementFuncsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get management funcs job state details
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} managementFuncJobStateId Management Func Job identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getManagementFuncRunState(workspaceId: string, changeSetId: string, managementFuncJobStateId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetManagementFuncJobStateV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getManagementFuncRunState(workspaceId, changeSetId, managementFuncJobStateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManagementFuncsApi.getManagementFuncRunState']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManagementFuncsApi - factory interface
 * @export
 */
export const ManagementFuncsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagementFuncsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get management funcs job state details
         * @param {ManagementFuncsApiGetManagementFuncRunStateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getManagementFuncRunState(requestParameters: ManagementFuncsApiGetManagementFuncRunStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetManagementFuncJobStateV1Response> {
            return localVarFp.getManagementFuncRunState(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.managementFuncJobStateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagementFuncsApi - interface
 * @export
 * @interface ManagementFuncsApi
 */
export interface ManagementFuncsApiInterface {
    /**
     * 
     * @summary Get management funcs job state details
     * @param {ManagementFuncsApiGetManagementFuncRunStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagementFuncsApiInterface
     */
    getManagementFuncRunState(requestParameters: ManagementFuncsApiGetManagementFuncRunStateRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetManagementFuncJobStateV1Response>;

}

/**
 * Request parameters for getManagementFuncRunState operation in ManagementFuncsApi.
 * @export
 * @interface ManagementFuncsApiGetManagementFuncRunStateRequest
 */
export interface ManagementFuncsApiGetManagementFuncRunStateRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof ManagementFuncsApiGetManagementFuncRunState
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof ManagementFuncsApiGetManagementFuncRunState
     */
    readonly changeSetId: string

    /**
     * Management Func Job identifier
     * @type {string}
     * @memberof ManagementFuncsApiGetManagementFuncRunState
     */
    readonly managementFuncJobStateId: string
}

/**
 * ManagementFuncsApi - object-oriented interface
 * @export
 * @class ManagementFuncsApi
 * @extends {BaseAPI}
 */
export class ManagementFuncsApi extends BaseAPI implements ManagementFuncsApiInterface {
    /**
     * 
     * @summary Get management funcs job state details
     * @param {ManagementFuncsApiGetManagementFuncRunStateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagementFuncsApi
     */
    public getManagementFuncRunState(requestParameters: ManagementFuncsApiGetManagementFuncRunStateRequest, options?: RawAxiosRequestConfig) {
        return ManagementFuncsApiFp(this.configuration).getManagementFuncRunState(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.managementFuncJobStateId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RootApi - axios parameter creator
 * @export
 */
export const RootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatusRoute: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RootApi - functional programming interface
 * @export
 */
export const RootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RootApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemStatusRoute(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemStatusRoute(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RootApi.systemStatusRoute']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RootApi - factory interface
 * @export
 */
export const RootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RootApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemStatusRoute(options?: RawAxiosRequestConfig): AxiosPromise<SystemStatusResponse> {
            return localVarFp.systemStatusRoute(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RootApi - interface
 * @export
 * @interface RootApi
 */
export interface RootApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApiInterface
     */
    systemStatusRoute(options?: RawAxiosRequestConfig): AxiosPromise<SystemStatusResponse>;

}

/**
 * RootApi - object-oriented interface
 * @export
 * @class RootApi
 * @extends {BaseAPI}
 */
export class RootApi extends BaseAPI implements RootApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RootApi
     */
    public systemStatusRoute(options?: RawAxiosRequestConfig) {
        return RootApiFp(this.configuration).systemStatusRoute(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SchemasApi - axios parameter creator
 * @export
 */
export const SchemasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a schema and it\'s default variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateSchemaV1Request} createSchemaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchema: async (workspaceId: string, changeSetId: string, createSchemaV1Request: CreateSchemaV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSchema', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createSchema', 'changeSetId', changeSetId)
            // verify required parameter 'createSchemaV1Request' is not null or undefined
            assertParamExists('createSchema', 'createSchemaV1Request', createSchemaV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSchemaV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an action function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantActionFuncV1Request} createVariantActionFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantAction: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantActionFuncV1Request: CreateVariantActionFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createVariantAction', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createVariantAction', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('createVariantAction', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('createVariantAction', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'createVariantActionFuncV1Request' is not null or undefined
            assertParamExists('createVariantAction', 'createVariantActionFuncV1Request', createVariantActionFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}/funcs/action`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantActionFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an authentication function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantAuthenticationFuncV1Request} createVariantAuthenticationFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantAuthentication: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantAuthenticationFuncV1Request: CreateVariantAuthenticationFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createVariantAuthentication', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createVariantAuthentication', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('createVariantAuthentication', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('createVariantAuthentication', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'createVariantAuthenticationFuncV1Request' is not null or undefined
            assertParamExists('createVariantAuthentication', 'createVariantAuthenticationFuncV1Request', createVariantAuthenticationFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}/funcs/authentication`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantAuthenticationFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a codegen function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantCodegenFuncV1Request} createVariantCodegenFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantCodegen: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantCodegenFuncV1Request: CreateVariantCodegenFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createVariantCodegen', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createVariantCodegen', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('createVariantCodegen', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('createVariantCodegen', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'createVariantCodegenFuncV1Request' is not null or undefined
            assertParamExists('createVariantCodegen', 'createVariantCodegenFuncV1Request', createVariantCodegenFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}/funcs/codegen`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantCodegenFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a management function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantManagementFuncV1Request} createVariantManagementFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantManagement: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantManagementFuncV1Request: CreateVariantManagementFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createVariantManagement', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createVariantManagement', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('createVariantManagement', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('createVariantManagement', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'createVariantManagementFuncV1Request' is not null or undefined
            assertParamExists('createVariantManagement', 'createVariantManagementFuncV1Request', createVariantManagementFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}/funcs/management`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantManagementFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a qualification and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantQualificationFuncV1Request} createVariantQualificationFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantQualification: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantQualificationFuncV1Request: CreateVariantQualificationFuncV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createVariantQualification', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createVariantQualification', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('createVariantQualification', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('createVariantQualification', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'createVariantQualificationFuncV1Request' is not null or undefined
            assertParamExists('createVariantQualification', 'createVariantQualificationFuncV1Request', createVariantQualificationFuncV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}/funcs/qualification`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVariantQualificationFuncV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find schema by name or schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string | null} [schema] 
         * @param {string | null} [schemaId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSchema: async (workspaceId: string, changeSetId: string, schema?: string | null, schemaId?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('findSchema', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('findSchema', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/find`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (schema !== undefined) {
                localVarQueryParameter['schema'] = schema;
            }

            if (schemaId !== undefined) {
                localVarQueryParameter['schemaId'] = schemaId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the default variant for a schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultVariant: async (workspaceId: string, changeSetId: string, schemaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getDefaultVariant', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getDefaultVariant', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getDefaultVariant', 'schemaId', schemaId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/default`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a schema by schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema: async (workspaceId: string, changeSetId: string, schemaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSchema', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getSchema', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getSchema', 'schemaId', schemaId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a schema variant by schema id and schema variant id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariant: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getVariant', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getVariant', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('getVariant', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('getVariant', 'schemaVariantId', schemaVariantId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all schemas (paginated endpoint)
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} [limit] Maximum number of results to return (default: 50, max: 300)
         * @param {string} [cursor] Cursor for pagination (SchemaId of the last item from previous page)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas: async (workspaceId: string, changeSetId: string, limit?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('listSchemas', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('listSchemas', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Complex search for shemas
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {SearchSchemasV1Request} searchSchemasV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSchemas: async (workspaceId: string, changeSetId: string, searchSchemasV1Request: SearchSchemasV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('searchSchemas', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('searchSchemas', 'changeSetId', changeSetId)
            // verify required parameter 'searchSchemasV1Request' is not null or undefined
            assertParamExists('searchSchemas', 'searchSchemasV1Request', searchSchemasV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/search`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchSchemasV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unlocks a schema - if there\'s already an unlocked variant, then we return that
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockSchema: async (workspaceId: string, changeSetId: string, schemaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('unlockSchema', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('unlockSchema', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('unlockSchema', 'schemaId', schemaId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/unlock`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the schema variant and regenerate
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {UpdateSchemaVariantV1Request} updateSchemaVariantV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchemaVariant: async (workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, updateSchemaVariantV1Request: UpdateSchemaVariantV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateSchemaVariant', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('updateSchemaVariant', 'changeSetId', changeSetId)
            // verify required parameter 'schemaId' is not null or undefined
            assertParamExists('updateSchemaVariant', 'schemaId', schemaId)
            // verify required parameter 'schemaVariantId' is not null or undefined
            assertParamExists('updateSchemaVariant', 'schemaVariantId', schemaVariantId)
            // verify required parameter 'updateSchemaVariantV1Request' is not null or undefined
            assertParamExists('updateSchemaVariant', 'updateSchemaVariantV1Request', updateSchemaVariantV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/schemas/{schema_id}/variant/{schema_variant_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"schema_id"}}`, encodeURIComponent(String(schemaId)))
                .replace(`{${"schema_variant_id"}}`, encodeURIComponent(String(schemaVariantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSchemaVariantV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemasApi - functional programming interface
 * @export
 */
export const SchemasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a schema and it\'s default variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateSchemaV1Request} createSchemaV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchema(workspaceId: string, changeSetId: string, createSchemaV1Request: CreateSchemaV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSchemaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchema(workspaceId, changeSetId, createSchemaV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an action function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantActionFuncV1Request} createVariantActionFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariantAction(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantActionFuncV1Request: CreateVariantActionFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVariantActionFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariantAction(workspaceId, changeSetId, schemaId, schemaVariantId, createVariantActionFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createVariantAction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an authentication function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantAuthenticationFuncV1Request} createVariantAuthenticationFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariantAuthentication(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantAuthenticationFuncV1Request: CreateVariantAuthenticationFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVariantAuthenticationFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariantAuthentication(workspaceId, changeSetId, schemaId, schemaVariantId, createVariantAuthenticationFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createVariantAuthentication']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a codegen function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantCodegenFuncV1Request} createVariantCodegenFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariantCodegen(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantCodegenFuncV1Request: CreateVariantCodegenFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVariantCodegenFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariantCodegen(workspaceId, changeSetId, schemaId, schemaVariantId, createVariantCodegenFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createVariantCodegen']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a management function and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantManagementFuncV1Request} createVariantManagementFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariantManagement(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantManagementFuncV1Request: CreateVariantManagementFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVariantManagementFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariantManagement(workspaceId, changeSetId, schemaId, schemaVariantId, createVariantManagementFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createVariantManagement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a qualification and attach to a schema variant
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {CreateVariantQualificationFuncV1Request} createVariantQualificationFuncV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVariantQualification(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, createVariantQualificationFuncV1Request: CreateVariantQualificationFuncV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateVariantQualificationFuncV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVariantQualification(workspaceId, changeSetId, schemaId, schemaVariantId, createVariantQualificationFuncV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.createVariantQualification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Find schema by name or schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string | null} [schema] 
         * @param {string | null} [schemaId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSchema(workspaceId: string, changeSetId: string, schema?: string | null, schemaId?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindSchemaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSchema(workspaceId, changeSetId, schema, schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.findSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get the default variant for a schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDefaultVariant(workspaceId: string, changeSetId: string, schemaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSchemaVariantV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultVariant(workspaceId, changeSetId, schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getDefaultVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a schema by schema id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchema(workspaceId: string, changeSetId: string, schemaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSchemaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchema(workspaceId, changeSetId, schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a schema variant by schema id and schema variant id
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVariant(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSchemaVariantV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVariant(workspaceId, changeSetId, schemaId, schemaVariantId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.getVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all schemas (paginated endpoint)
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} [limit] Maximum number of results to return (default: 50, max: 300)
         * @param {string} [cursor] Cursor for pagination (SchemaId of the last item from previous page)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSchemas(workspaceId: string, changeSetId: string, limit?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSchemaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSchemas(workspaceId, changeSetId, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.listSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Complex search for shemas
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {SearchSchemasV1Request} searchSchemasV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSchemas(workspaceId: string, changeSetId: string, searchSchemasV1Request: SearchSchemasV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchSchemasV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSchemas(workspaceId, changeSetId, searchSchemasV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.searchSchemas']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Unlocks a schema - if there\'s already an unlocked variant, then we return that
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlockSchema(workspaceId: string, changeSetId: string, schemaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnlockedSchemaV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlockSchema(workspaceId, changeSetId, schemaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.unlockSchema']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the schema variant and regenerate
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} schemaId Schema identifier
         * @param {string} schemaVariantId Schema variant identifier
         * @param {UpdateSchemaVariantV1Request} updateSchemaVariantV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchemaVariant(workspaceId: string, changeSetId: string, schemaId: string, schemaVariantId: string, updateSchemaVariantV1Request: UpdateSchemaVariantV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSchemaVariantV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchemaVariant(workspaceId, changeSetId, schemaId, schemaVariantId, updateSchemaVariantV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SchemasApi.updateSchemaVariant']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SchemasApi - factory interface
 * @export
 */
export const SchemasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemasApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a schema and it\'s default variant
         * @param {SchemasApiCreateSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchema(requestParameters: SchemasApiCreateSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaV1Response> {
            return localVarFp.createSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createSchemaV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an action function and attach to a schema variant
         * @param {SchemasApiCreateVariantActionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantAction(requestParameters: SchemasApiCreateVariantActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantActionFuncV1Response> {
            return localVarFp.createVariantAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantActionFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an authentication function and attach to a schema variant
         * @param {SchemasApiCreateVariantAuthenticationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantAuthentication(requestParameters: SchemasApiCreateVariantAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantAuthenticationFuncV1Response> {
            return localVarFp.createVariantAuthentication(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantAuthenticationFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a codegen function and attach to a schema variant
         * @param {SchemasApiCreateVariantCodegenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantCodegen(requestParameters: SchemasApiCreateVariantCodegenRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantCodegenFuncV1Response> {
            return localVarFp.createVariantCodegen(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantCodegenFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a management function and attach to a schema variant
         * @param {SchemasApiCreateVariantManagementRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantManagement(requestParameters: SchemasApiCreateVariantManagementRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantManagementFuncV1Response> {
            return localVarFp.createVariantManagement(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantManagementFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a qualification and attach to a schema variant
         * @param {SchemasApiCreateVariantQualificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVariantQualification(requestParameters: SchemasApiCreateVariantQualificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantQualificationFuncV1Response> {
            return localVarFp.createVariantQualification(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantQualificationFuncV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find schema by name or schema id
         * @param {SchemasApiFindSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSchema(requestParameters: SchemasApiFindSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<FindSchemaV1Response> {
            return localVarFp.findSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schema, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the default variant for a schema id
         * @param {SchemasApiGetDefaultVariantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDefaultVariant(requestParameters: SchemasApiGetDefaultVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response> {
            return localVarFp.getDefaultVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a schema by schema id
         * @param {SchemasApiGetSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchema(requestParameters: SchemasApiGetSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaV1Response> {
            return localVarFp.getSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a schema variant by schema id and schema variant id
         * @param {SchemasApiGetVariantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVariant(requestParameters: SchemasApiGetVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response> {
            return localVarFp.getVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all schemas (paginated endpoint)
         * @param {SchemasApiListSchemasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSchemas(requestParameters: SchemasApiListSchemasRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListSchemaV1Response> {
            return localVarFp.listSchemas(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Complex search for shemas
         * @param {SchemasApiSearchSchemasRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSchemas(requestParameters: SchemasApiSearchSchemasRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchSchemasV1Response> {
            return localVarFp.searchSchemas(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.searchSchemasV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unlocks a schema - if there\'s already an unlocked variant, then we return that
         * @param {SchemasApiUnlockSchemaRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlockSchema(requestParameters: SchemasApiUnlockSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnlockedSchemaV1Response> {
            return localVarFp.unlockSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the schema variant and regenerate
         * @param {SchemasApiUpdateSchemaVariantRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchemaVariant(requestParameters: SchemasApiUpdateSchemaVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response> {
            return localVarFp.updateSchemaVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.updateSchemaVariantV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemasApi - interface
 * @export
 * @interface SchemasApi
 */
export interface SchemasApiInterface {
    /**
     * 
     * @summary Create a schema and it\'s default variant
     * @param {SchemasApiCreateSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createSchema(requestParameters: SchemasApiCreateSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaV1Response>;

    /**
     * 
     * @summary Create an action function and attach to a schema variant
     * @param {SchemasApiCreateVariantActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createVariantAction(requestParameters: SchemasApiCreateVariantActionRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantActionFuncV1Response>;

    /**
     * 
     * @summary Create an authentication function and attach to a schema variant
     * @param {SchemasApiCreateVariantAuthenticationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createVariantAuthentication(requestParameters: SchemasApiCreateVariantAuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantAuthenticationFuncV1Response>;

    /**
     * 
     * @summary Create a codegen function and attach to a schema variant
     * @param {SchemasApiCreateVariantCodegenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createVariantCodegen(requestParameters: SchemasApiCreateVariantCodegenRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantCodegenFuncV1Response>;

    /**
     * 
     * @summary Create a management function and attach to a schema variant
     * @param {SchemasApiCreateVariantManagementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createVariantManagement(requestParameters: SchemasApiCreateVariantManagementRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantManagementFuncV1Response>;

    /**
     * 
     * @summary Create a qualification and attach to a schema variant
     * @param {SchemasApiCreateVariantQualificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    createVariantQualification(requestParameters: SchemasApiCreateVariantQualificationRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateVariantQualificationFuncV1Response>;

    /**
     * 
     * @summary Find schema by name or schema id
     * @param {SchemasApiFindSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    findSchema(requestParameters: SchemasApiFindSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<FindSchemaV1Response>;

    /**
     * 
     * @summary Get the default variant for a schema id
     * @param {SchemasApiGetDefaultVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    getDefaultVariant(requestParameters: SchemasApiGetDefaultVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response>;

    /**
     * 
     * @summary Get a schema by schema id
     * @param {SchemasApiGetSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    getSchema(requestParameters: SchemasApiGetSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaV1Response>;

    /**
     * 
     * @summary Get a schema variant by schema id and schema variant id
     * @param {SchemasApiGetVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    getVariant(requestParameters: SchemasApiGetVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response>;

    /**
     * 
     * @summary List all schemas (paginated endpoint)
     * @param {SchemasApiListSchemasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    listSchemas(requestParameters: SchemasApiListSchemasRequest, options?: RawAxiosRequestConfig): AxiosPromise<ListSchemaV1Response>;

    /**
     * 
     * @summary Complex search for shemas
     * @param {SchemasApiSearchSchemasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    searchSchemas(requestParameters: SchemasApiSearchSchemasRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchSchemasV1Response>;

    /**
     * 
     * @summary Unlocks a schema - if there\'s already an unlocked variant, then we return that
     * @param {SchemasApiUnlockSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    unlockSchema(requestParameters: SchemasApiUnlockSchemaRequest, options?: RawAxiosRequestConfig): AxiosPromise<UnlockedSchemaV1Response>;

    /**
     * 
     * @summary Update the schema variant and regenerate
     * @param {SchemasApiUpdateSchemaVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApiInterface
     */
    updateSchemaVariant(requestParameters: SchemasApiUpdateSchemaVariantRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetSchemaVariantV1Response>;

}

/**
 * Request parameters for createSchema operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateSchemaRequest
 */
export interface SchemasApiCreateSchemaRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateSchema
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateSchema
     */
    readonly changeSetId: string

    /**
     * 
     * @type {CreateSchemaV1Request}
     * @memberof SchemasApiCreateSchema
     */
    readonly createSchemaV1Request: CreateSchemaV1Request
}

/**
 * Request parameters for createVariantAction operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateVariantActionRequest
 */
export interface SchemasApiCreateVariantActionRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAction
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAction
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAction
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAction
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {CreateVariantActionFuncV1Request}
     * @memberof SchemasApiCreateVariantAction
     */
    readonly createVariantActionFuncV1Request: CreateVariantActionFuncV1Request
}

/**
 * Request parameters for createVariantAuthentication operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateVariantAuthenticationRequest
 */
export interface SchemasApiCreateVariantAuthenticationRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAuthentication
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAuthentication
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAuthentication
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantAuthentication
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {CreateVariantAuthenticationFuncV1Request}
     * @memberof SchemasApiCreateVariantAuthentication
     */
    readonly createVariantAuthenticationFuncV1Request: CreateVariantAuthenticationFuncV1Request
}

/**
 * Request parameters for createVariantCodegen operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateVariantCodegenRequest
 */
export interface SchemasApiCreateVariantCodegenRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantCodegen
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantCodegen
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantCodegen
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantCodegen
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {CreateVariantCodegenFuncV1Request}
     * @memberof SchemasApiCreateVariantCodegen
     */
    readonly createVariantCodegenFuncV1Request: CreateVariantCodegenFuncV1Request
}

/**
 * Request parameters for createVariantManagement operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateVariantManagementRequest
 */
export interface SchemasApiCreateVariantManagementRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantManagement
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantManagement
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantManagement
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantManagement
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {CreateVariantManagementFuncV1Request}
     * @memberof SchemasApiCreateVariantManagement
     */
    readonly createVariantManagementFuncV1Request: CreateVariantManagementFuncV1Request
}

/**
 * Request parameters for createVariantQualification operation in SchemasApi.
 * @export
 * @interface SchemasApiCreateVariantQualificationRequest
 */
export interface SchemasApiCreateVariantQualificationRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantQualification
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantQualification
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantQualification
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiCreateVariantQualification
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {CreateVariantQualificationFuncV1Request}
     * @memberof SchemasApiCreateVariantQualification
     */
    readonly createVariantQualificationFuncV1Request: CreateVariantQualificationFuncV1Request
}

/**
 * Request parameters for findSchema operation in SchemasApi.
 * @export
 * @interface SchemasApiFindSchemaRequest
 */
export interface SchemasApiFindSchemaRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiFindSchema
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiFindSchema
     */
    readonly changeSetId: string

    /**
     * 
     * @type {string}
     * @memberof SchemasApiFindSchema
     */
    readonly schema?: string | null

    /**
     * 
     * @type {string}
     * @memberof SchemasApiFindSchema
     */
    readonly schemaId?: string | null
}

/**
 * Request parameters for getDefaultVariant operation in SchemasApi.
 * @export
 * @interface SchemasApiGetDefaultVariantRequest
 */
export interface SchemasApiGetDefaultVariantRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiGetDefaultVariant
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiGetDefaultVariant
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiGetDefaultVariant
     */
    readonly schemaId: string
}

/**
 * Request parameters for getSchema operation in SchemasApi.
 * @export
 * @interface SchemasApiGetSchemaRequest
 */
export interface SchemasApiGetSchemaRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiGetSchema
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiGetSchema
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiGetSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for getVariant operation in SchemasApi.
 * @export
 * @interface SchemasApiGetVariantRequest
 */
export interface SchemasApiGetVariantRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiGetVariant
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiGetVariant
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiGetVariant
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiGetVariant
     */
    readonly schemaVariantId: string
}

/**
 * Request parameters for listSchemas operation in SchemasApi.
 * @export
 * @interface SchemasApiListSchemasRequest
 */
export interface SchemasApiListSchemasRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiListSchemas
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiListSchemas
     */
    readonly changeSetId: string

    /**
     * Maximum number of results to return (default: 50, max: 300)
     * @type {string}
     * @memberof SchemasApiListSchemas
     */
    readonly limit?: string

    /**
     * Cursor for pagination (SchemaId of the last item from previous page)
     * @type {string}
     * @memberof SchemasApiListSchemas
     */
    readonly cursor?: string
}

/**
 * Request parameters for searchSchemas operation in SchemasApi.
 * @export
 * @interface SchemasApiSearchSchemasRequest
 */
export interface SchemasApiSearchSchemasRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiSearchSchemas
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiSearchSchemas
     */
    readonly changeSetId: string

    /**
     * 
     * @type {SearchSchemasV1Request}
     * @memberof SchemasApiSearchSchemas
     */
    readonly searchSchemasV1Request: SearchSchemasV1Request
}

/**
 * Request parameters for unlockSchema operation in SchemasApi.
 * @export
 * @interface SchemasApiUnlockSchemaRequest
 */
export interface SchemasApiUnlockSchemaRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiUnlockSchema
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiUnlockSchema
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiUnlockSchema
     */
    readonly schemaId: string
}

/**
 * Request parameters for updateSchemaVariant operation in SchemasApi.
 * @export
 * @interface SchemasApiUpdateSchemaVariantRequest
 */
export interface SchemasApiUpdateSchemaVariantRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SchemasApiUpdateSchemaVariant
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SchemasApiUpdateSchemaVariant
     */
    readonly changeSetId: string

    /**
     * Schema identifier
     * @type {string}
     * @memberof SchemasApiUpdateSchemaVariant
     */
    readonly schemaId: string

    /**
     * Schema variant identifier
     * @type {string}
     * @memberof SchemasApiUpdateSchemaVariant
     */
    readonly schemaVariantId: string

    /**
     * 
     * @type {UpdateSchemaVariantV1Request}
     * @memberof SchemasApiUpdateSchemaVariant
     */
    readonly updateSchemaVariantV1Request: UpdateSchemaVariantV1Request
}

/**
 * SchemasApi - object-oriented interface
 * @export
 * @class SchemasApi
 * @extends {BaseAPI}
 */
export class SchemasApi extends BaseAPI implements SchemasApiInterface {
    /**
     * 
     * @summary Create a schema and it\'s default variant
     * @param {SchemasApiCreateSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createSchema(requestParameters: SchemasApiCreateSchemaRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createSchemaV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an action function and attach to a schema variant
     * @param {SchemasApiCreateVariantActionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createVariantAction(requestParameters: SchemasApiCreateVariantActionRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createVariantAction(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantActionFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an authentication function and attach to a schema variant
     * @param {SchemasApiCreateVariantAuthenticationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createVariantAuthentication(requestParameters: SchemasApiCreateVariantAuthenticationRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createVariantAuthentication(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantAuthenticationFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a codegen function and attach to a schema variant
     * @param {SchemasApiCreateVariantCodegenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createVariantCodegen(requestParameters: SchemasApiCreateVariantCodegenRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createVariantCodegen(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantCodegenFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a management function and attach to a schema variant
     * @param {SchemasApiCreateVariantManagementRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createVariantManagement(requestParameters: SchemasApiCreateVariantManagementRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createVariantManagement(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantManagementFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a qualification and attach to a schema variant
     * @param {SchemasApiCreateVariantQualificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public createVariantQualification(requestParameters: SchemasApiCreateVariantQualificationRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).createVariantQualification(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.createVariantQualificationFuncV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find schema by name or schema id
     * @param {SchemasApiFindSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public findSchema(requestParameters: SchemasApiFindSchemaRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).findSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schema, requestParameters.schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the default variant for a schema id
     * @param {SchemasApiGetDefaultVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getDefaultVariant(requestParameters: SchemasApiGetDefaultVariantRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getDefaultVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a schema by schema id
     * @param {SchemasApiGetSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getSchema(requestParameters: SchemasApiGetSchemaRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a schema variant by schema id and schema variant id
     * @param {SchemasApiGetVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public getVariant(requestParameters: SchemasApiGetVariantRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).getVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all schemas (paginated endpoint)
     * @param {SchemasApiListSchemasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public listSchemas(requestParameters: SchemasApiListSchemasRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).listSchemas(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Complex search for shemas
     * @param {SchemasApiSearchSchemasRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public searchSchemas(requestParameters: SchemasApiSearchSchemasRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).searchSchemas(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.searchSchemasV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unlocks a schema - if there\'s already an unlocked variant, then we return that
     * @param {SchemasApiUnlockSchemaRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public unlockSchema(requestParameters: SchemasApiUnlockSchemaRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).unlockSchema(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the schema variant and regenerate
     * @param {SchemasApiUpdateSchemaVariantRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemasApi
     */
    public updateSchemaVariant(requestParameters: SchemasApiUpdateSchemaVariantRequest, options?: RawAxiosRequestConfig) {
        return SchemasApiFp(this.configuration).updateSchemaVariant(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.schemaId, requestParameters.schemaVariantId, requestParameters.updateSchemaVariantV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Complex search for components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} q Query string. See https://docs.systeminit.com/explanation/search-syntax for details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search: async (workspaceId: string, changeSetId: string, q: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('search', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('search', 'changeSetId', changeSetId)
            // verify required parameter 'q' is not null or undefined
            assertParamExists('search', 'q', q)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/search`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Complex search for components
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} q Query string. See https://docs.systeminit.com/explanation/search-syntax for details.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async search(workspaceId: string, changeSetId: string, q: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.search(workspaceId, changeSetId, q, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.search']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * 
         * @summary Complex search for components
         * @param {SearchApiSearchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(requestParameters: SearchApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchV1Response> {
            return localVarFp.search(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.q, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - interface
 * @export
 * @interface SearchApi
 */
export interface SearchApiInterface {
    /**
     * 
     * @summary Complex search for components
     * @param {SearchApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApiInterface
     */
    search(requestParameters: SearchApiSearchRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchV1Response>;

}

/**
 * Request parameters for search operation in SearchApi.
 * @export
 * @interface SearchApiSearchRequest
 */
export interface SearchApiSearchRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly changeSetId: string

    /**
     * Query string. See https://docs.systeminit.com/explanation/search-syntax for details.
     * @type {string}
     * @memberof SearchApiSearch
     */
    readonly q: string
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI implements SearchApiInterface {
    /**
     * 
     * @summary Complex search for components
     * @param {SearchApiSearchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(requestParameters: SearchApiSearchRequest, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).search(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.q, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecretsApi - axios parameter creator
 * @export
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateSecretV1Request} createSecretV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret: async (workspaceId: string, changeSetId: string, createSecretV1Request: CreateSecretV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('createSecret', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('createSecret', 'changeSetId', changeSetId)
            // verify required parameter 'createSecretV1Request' is not null or undefined
            assertParamExists('createSecret', 'createSecretV1Request', createSecretV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/secrets`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSecretV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} secretId Secret identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret: async (workspaceId: string, changeSetId: string, secretId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('deleteSecret', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('deleteSecret', 'changeSetId', changeSetId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('deleteSecret', 'secretId', secretId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/secrets/{secret_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"secret_id"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all secrets
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecrets: async (workspaceId: string, changeSetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('getSecrets', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('getSecrets', 'changeSetId', changeSetId)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/secrets`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} secretId Secret identifier
         * @param {UpdateSecretV1Request} updateSecretV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret: async (workspaceId: string, changeSetId: string, secretId: string, updateSecretV1Request: UpdateSecretV1Request, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists('updateSecret', 'workspaceId', workspaceId)
            // verify required parameter 'changeSetId' is not null or undefined
            assertParamExists('updateSecret', 'changeSetId', changeSetId)
            // verify required parameter 'secretId' is not null or undefined
            assertParamExists('updateSecret', 'secretId', secretId)
            // verify required parameter 'updateSecretV1Request' is not null or undefined
            assertParamExists('updateSecret', 'updateSecretV1Request', updateSecretV1Request)
            const localVarPath = `/v1/w/{workspace_id}/change-sets/{change_set_id}/secrets/{secret_id}`
                .replace(`{${"workspace_id"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"change_set_id"}}`, encodeURIComponent(String(changeSetId)))
                .replace(`{${"secret_id"}}`, encodeURIComponent(String(secretId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateSecretV1Request, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {CreateSecretV1Request} createSecretV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSecret(workspaceId: string, changeSetId: string, createSecretV1Request: CreateSecretV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSecretV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSecret(workspaceId, changeSetId, createSecretV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.createSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} secretId Secret identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSecret(workspaceId: string, changeSetId: string, secretId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteSecretV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSecret(workspaceId, changeSetId, secretId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.deleteSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all secrets
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecrets(workspaceId: string, changeSetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: HashMapValue; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecrets(workspaceId, changeSetId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.getSecrets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update a secret
         * @param {string} workspaceId Workspace identifier
         * @param {string} changeSetId Change Set identifier
         * @param {string} secretId Secret identifier
         * @param {UpdateSecretV1Request} updateSecretV1Request 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSecret(workspaceId: string, changeSetId: string, secretId: string, updateSecretV1Request: UpdateSecretV1Request, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateSecretV1Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSecret(workspaceId, changeSetId, secretId, updateSecretV1Request, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecretsApi.updateSecret']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a secret
         * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateSecretV1Response> {
            return localVarFp.createSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createSecretV1Request, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a secret
         * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteSecretV1Response> {
            return localVarFp.deleteSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.secretId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all secrets
         * @param {SecretsApiGetSecretsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecrets(requestParameters: SecretsApiGetSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: HashMapValue; }> {
            return localVarFp.getSecrets(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a secret
         * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateSecretV1Response> {
            return localVarFp.updateSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.secretId, requestParameters.updateSecretV1Request, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecretsApi - interface
 * @export
 * @interface SecretsApi
 */
export interface SecretsApiInterface {
    /**
     * 
     * @summary Create a secret
     * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateSecretV1Response>;

    /**
     * 
     * @summary Delete a secret
     * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteSecretV1Response>;

    /**
     * 
     * @summary List all secrets
     * @param {SecretsApiGetSecretsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    getSecrets(requestParameters: SecretsApiGetSecretsRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: HashMapValue; }>;

    /**
     * 
     * @summary Update a secret
     * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApiInterface
     */
    updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateSecretV1Response>;

}

/**
 * Request parameters for createSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiCreateSecretRequest
 */
export interface SecretsApiCreateSecretRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SecretsApiCreateSecret
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SecretsApiCreateSecret
     */
    readonly changeSetId: string

    /**
     * 
     * @type {CreateSecretV1Request}
     * @memberof SecretsApiCreateSecret
     */
    readonly createSecretV1Request: CreateSecretV1Request
}

/**
 * Request parameters for deleteSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiDeleteSecretRequest
 */
export interface SecretsApiDeleteSecretRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SecretsApiDeleteSecret
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SecretsApiDeleteSecret
     */
    readonly changeSetId: string

    /**
     * Secret identifier
     * @type {string}
     * @memberof SecretsApiDeleteSecret
     */
    readonly secretId: string
}

/**
 * Request parameters for getSecrets operation in SecretsApi.
 * @export
 * @interface SecretsApiGetSecretsRequest
 */
export interface SecretsApiGetSecretsRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SecretsApiGetSecrets
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SecretsApiGetSecrets
     */
    readonly changeSetId: string
}

/**
 * Request parameters for updateSecret operation in SecretsApi.
 * @export
 * @interface SecretsApiUpdateSecretRequest
 */
export interface SecretsApiUpdateSecretRequest {
    /**
     * Workspace identifier
     * @type {string}
     * @memberof SecretsApiUpdateSecret
     */
    readonly workspaceId: string

    /**
     * Change Set identifier
     * @type {string}
     * @memberof SecretsApiUpdateSecret
     */
    readonly changeSetId: string

    /**
     * Secret identifier
     * @type {string}
     * @memberof SecretsApiUpdateSecret
     */
    readonly secretId: string

    /**
     * 
     * @type {UpdateSecretV1Request}
     * @memberof SecretsApiUpdateSecret
     */
    readonly updateSecretV1Request: UpdateSecretV1Request
}

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI implements SecretsApiInterface {
    /**
     * 
     * @summary Create a secret
     * @param {SecretsApiCreateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public createSecret(requestParameters: SecretsApiCreateSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).createSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.createSecretV1Request, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a secret
     * @param {SecretsApiDeleteSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public deleteSecret(requestParameters: SecretsApiDeleteSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).deleteSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.secretId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all secrets
     * @param {SecretsApiGetSecretsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public getSecrets(requestParameters: SecretsApiGetSecretsRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).getSecrets(requestParameters.workspaceId, requestParameters.changeSetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a secret
     * @param {SecretsApiUpdateSecretRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public updateSecret(requestParameters: SecretsApiUpdateSecretRequest, options?: RawAxiosRequestConfig) {
        return SecretsApiFp(this.configuration).updateSecret(requestParameters.workspaceId, requestParameters.changeSetId, requestParameters.secretId, requestParameters.updateSecretV1Request, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WhoamiApi - axios parameter creator
 * @export
 */
export const WhoamiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/whoami`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WhoamiApi - functional programming interface
 * @export
 */
export const WhoamiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WhoamiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async whoami(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WhoamiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.whoami(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WhoamiApi.whoami']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WhoamiApi - factory interface
 * @export
 */
export const WhoamiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WhoamiApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: RawAxiosRequestConfig): AxiosPromise<WhoamiResponse> {
            return localVarFp.whoami(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WhoamiApi - interface
 * @export
 * @interface WhoamiApi
 */
export interface WhoamiApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhoamiApiInterface
     */
    whoami(options?: RawAxiosRequestConfig): AxiosPromise<WhoamiResponse>;

}

/**
 * WhoamiApi - object-oriented interface
 * @export
 * @class WhoamiApi
 * @extends {BaseAPI}
 */
export class WhoamiApi extends BaseAPI implements WhoamiApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WhoamiApi
     */
    public whoami(options?: RawAxiosRequestConfig) {
        return WhoamiApiFp(this.configuration).whoami(options).then((request) => request(this.axios, this.basePath));
    }
}



