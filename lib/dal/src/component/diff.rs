//! This module contains [`ComponentDiff`].
use serde::{Deserialize, Serialize};
use serde_json::json;

use crate::code_view::{CodeLanguage, CodeView};
use crate::component::ComponentResult;
use crate::component::properties::ComponentProperties;
use crate::{Component, ComponentId, DalContext};

//
const NEWLINE: &str = "\n";

/// Contains the "diffs" for a given [`Component`](crate::Component). Generated by
/// [`Self::new()`].
#[derive(Deserialize, Serialize, Debug)]
pub struct ComponentDiff {
    pub component_id: ComponentId,
    /// The [`Component's`](crate::Component) [`CodeView`](crate::code_view::CodeView) found in the
    /// current [`Visibility`](crate::Visibility).
    pub current: CodeView,
    /// The "diff(s)" between [`Component`](crate::Component)'s
    /// [`CodeViews`](crate::code_view::CodeView) found on _head_ and found in the current
    /// [`Visibility`](crate::Visibility).
    ///
    /// This will be empty if the [`Component`](crate::Component) has been newly added.
    pub diffs: Vec<CodeView>,
}

impl Component {
    pub async fn get_diff(
        ctx: &DalContext,
        component_id: ComponentId,
    ) -> ComponentResult<ComponentDiff> {
        let component = Self::get_by_id(ctx, component_id).await?;
        let curr_json: String;
        let view = component.view(ctx).await?;
        if let Some(view) = view {
            let mut current_component_view = ComponentProperties::try_from(view)?;
            current_component_view.drop_private();
            curr_json = serde_json::to_string_pretty(&current_component_view)?;
        } else {
            curr_json = serde_json::to_string_pretty(&json!(null))?;
        }

        if ctx.change_set_id() == ctx.get_workspace_default_change_set_id().await? {
            // We are on HEAD and need to react as so!
            return Ok(ComponentDiff {
                component_id,
                current: CodeView::assemble(CodeLanguage::Json, Some(curr_json), None, None),
                diffs: vec![],
            });
        }

        let head_ctx = ctx.clone_with_head().await?;

        let head_json: String;
        let mut is_new_comp = false;
        let head_component = Self::get_by_id(&head_ctx, component_id).await;
        match head_component {
            Ok(comp) => {
                let view = comp.view(&head_ctx).await?;
                if let Some(view) = view {
                    let mut head_component_view = ComponentProperties::try_from(view)?;
                    head_component_view.drop_private();
                    head_component_view.drop_private();
                    head_json = serde_json::to_string_pretty(&head_component_view)?;
                } else {
                    head_json = serde_json::to_string_pretty(&json!(null))?;
                }
            }
            Err(_) => {
                is_new_comp = true;
                head_json = serde_json::to_string_pretty(&json!(null))?;
            }
        }

        let mut lines = Vec::new();
        for diff_object in diff::lines(&head_json, &curr_json) {
            let line = match diff_object {
                diff::Result::Left(left) => format!("-{left}"),
                diff::Result::Both(unchanged, _) => format!(" {unchanged}"),
                diff::Result::Right(right) => format!("+{right}"),
            };
            if line != "-null" {
                lines.push(line);
            }
        }
        let diff = CodeView::assemble(CodeLanguage::Diff, Some(lines.join(NEWLINE)), None, None);
        let diffs: Vec<CodeView> = vec![diff];

        Ok(ComponentDiff {
            component_id,
            current: CodeView::assemble(
                CodeLanguage::Json,
                if is_new_comp { Some(curr_json) } else { None },
                None,
                None,
            ),
            diffs,
        })
    }

    pub async fn get_json_representation(
        ctx: &DalContext,
        component_id: ComponentId,
    ) -> ComponentResult<ComponentProperties> {
        let component = Self::get_by_id(ctx, component_id).await?;
        let view = component.view(ctx).await?;

        if let Some(view) = view {
            let properties = ComponentProperties::try_from(view)?;
            return Ok(properties);
        }

        Ok(ComponentProperties::default())
    }
}
