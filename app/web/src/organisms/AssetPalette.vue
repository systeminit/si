<template>
  <template v-if="schemasReqStatus.isPending || addMenuReqStatus.isPending">
    loading...
  </template>
  <template v-else-if="schemasReqStatus.isSuccess">
    <!-- <SiSearch /> -->

    <p
      class="border-b-2 dark:border-neutral-600 text-sm leading-tight p-2.5 text-neutral-500"
    >
      Drag the assets that you wish to include in your application into the
      canvas to the right.
    </p>

    <ul class="overflow-y-auto">
      <SiCollapsible
        v-for="(category, categoryIndex) in addMenuData"
        :key="categoryIndex"
        :label="category.displayName"
        as="li"
        content-as="ul"
        default-open
        class="select-none"
      >
        <li
          v-for="(schema, schemaIndex) in category.schemas"
          :key="schemaIndex"
          class="select-none border-b-2 dark:border-neutral-600"
        >
          <SiNodeSprite
            :class="
              componentsStore.selectedInsertSchemaId === schema.id
                ? 'bg-action-100 dark:bg-action-700 border border-action-500 dark:border-action-300'
                : ''
            "
            :color="schema.color"
            :name="schema.displayName"
            class="border border-transparent hover:border-action-500 dark:hover:border-action-300 dark:text-white hover:text-action-500 dark:hover:text-action-500 hover:cursor-pointer"
            @mousedown.left="onSelect(schema.id)"
          />
        </li>
      </SiCollapsible>
    </ul>
  </template>
  <template v-if="selectedSchema">
    <Teleport to="body">
      <div
        ref="mouseNode"
        class="fixed top-0 pointer-events-none translate-x-[-50%] translate-y-[-50%] z-100"
      >
        <NodeSkeleton :color="selectedSchema.color" />
      </div>
    </Teleport>
  </template>
</template>

<script lang="ts" setup>
import _ from "lodash";
import { computed, onMounted, onBeforeUnmount, ref } from "vue";
import SiNodeSprite from "@/molecules/SiNodeSprite.vue";
import SiCollapsible from "@/organisms/SiCollapsible.vue";
import { useComponentsStore, MenuSchema } from "@/store/components.store";
import NodeSkeleton from "@/atoms/NodeSkeleton.vue";

const componentsStore = useComponentsStore();
// NOTE - component store is automatically fetching things we need when it is used
// otherwise we could trigger calls here

// TODO - probably should not need 2 requests here. currently we only use schema variants for the colors...
const schemasReqStatus = componentsStore.getRequestStatus(
  "FETCH_AVAILABLE_SCHEMAS",
);
const addMenuReqStatus = componentsStore.getRequestStatus(
  "FETCH_NODE_ADD_MENU",
);

const addMenuData = computed(() => componentsStore.nodeAddMenu);
const schemasById = computed(() => {
  return addMenuData.value.reduce((p, c) => {
    c.schemas.forEach((schema) => {
      p[schema.id] = schema;
    });
    return p;
  }, {} as Record<number, MenuSchema>);
});
const selectedSchema = computed(() => {
  if (componentsStore.selectedInsertSchemaId)
    return schemasById.value[componentsStore.selectedInsertSchemaId];
  return undefined;
});
const selecting = ref(false);
const mouseNode = ref();

const updateMouseNode = (e: MouseEvent) => {
  if (mouseNode.value) {
    const mouseX = e.clientX;
    const mouseY = e.clientY;
    mouseNode.value.style.left = `${mouseX}px`;
    mouseNode.value.style.top = `${mouseY}px`;
  }
};

function onSelect(schemaId: string) {
  componentsStore.selectedInsertSchemaId = schemaId;
  selecting.value = true;
}

function onDeselect() {
  componentsStore.selectedInsertSchemaId = null;
}

const onKeyDown = (e: KeyboardEvent) => {
  if (e.key === "Escape" || e.key === "Backspace") {
    onDeselect();
  }
};

const onMouseDown = (e: MouseEvent) => {
  updateMouseNode(e);
  if (selecting.value) selecting.value = false;
  else onDeselect();
};

const onMouseMove = (e: MouseEvent) => {
  updateMouseNode(e);
};

onMounted(() => {
  window.addEventListener("mousemove", onMouseMove);
  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("mousedown", onMouseDown);
});

onBeforeUnmount(() => {
  window.removeEventListener("mousemove", onMouseMove);
  window.removeEventListener("keydown", onKeyDown);
  window.removeEventListener("mousedown", onMouseDown);
});
</script>
